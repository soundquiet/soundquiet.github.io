<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">



  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Python,读书笔记,">





  <link rel="alternate" href="/atom.xml" title="Soundquiet" type="application/atom+xml">






<meta name="description" content="包括对象(第8、9章)、序列(第10章)、接口（第11章）、继承（第12章）、重载运算符（第13章）和生成器（第14章）">
<meta name="keywords" content="Python,读书笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="Fluent Python 读书笔记(4)">
<meta property="og:url" content="https://soundquiet.github.io/2018/11/02/Fluent-Python-读书笔记-4/index.html">
<meta property="og:site_name" content="Soundquiet">
<meta property="og:description" content="包括对象(第8、9章)、序列(第10章)、接口（第11章）、继承（第12章）、重载运算符（第13章）和生成器（第14章）">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://soundquiet.github.io/images/blogs/FluentPython/tuple.gif">
<meta property="og:image" content="https://soundquiet.github.io/images/blogs/FluentPython/copy.gif">
<meta property="og:image" content="https://soundquiet.github.io/images/blogs/FluentPython/diamond-uml.png">
<meta property="og:image" content="https://soundquiet.github.io/images/blogs/FluentPython/flowchart-operator.png">
<meta property="og:updated_time" content="2018-11-02T13:08:58.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Fluent Python 读书笔记(4)">
<meta name="twitter:description" content="包括对象(第8、9章)、序列(第10章)、接口（第11章）、继承（第12章）、重载运算符（第13章）和生成器（第14章）">
<meta name="twitter:image" content="https://soundquiet.github.io/images/blogs/FluentPython/tuple.gif">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://soundquiet.github.io/2018/11/02/Fluent-Python-读书笔记-4/">





  <title>Fluent Python 读书笔记(4) | Soundquiet</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?d9df1d344a31f6d468cc97c7697df391";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Soundquiet</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Life with studying, coding and ciuji</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://soundquiet.github.io/2018/11/02/Fluent-Python-读书笔记-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sun Fuling">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/sfl.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Soundquiet">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Fluent Python 读书笔记(4)</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-02T21:03:47+08:00">
                2018-11-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Fluent-Python/" itemprop="url" rel="index">
                    <span itemprop="name">Fluent Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/11/02/Fluent-Python-读书笔记-4/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count gitment-comments-count" data-xid="/2018/11/02/Fluent-Python-读书笔记-4/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>包括对象(第8、9章)、序列(第10章)、接口（第11章）、继承（第12章）、重载运算符（第13章）和生成器（第14章）<br><a id="more"></a></p>
<h1 id="Chap-8-对象引用、可变性和垃圾回收"><a href="#Chap-8-对象引用、可变性和垃圾回收" class="headerlink" title="Chap 8 对象引用、可变性和垃圾回收"></a>Chap 8 对象引用、可变性和垃圾回收</h1><h2 id="8-1-变量不是盒子"><a href="#8-1-变量不是盒子" class="headerlink" title="8.1 变量不是盒子"></a>8.1 变量不是盒子</h2><p>对于引用式变量来说，说<strong>把变量分配给对象</strong>更合理，毕竟，对象在赋值前就创建了。</p>
<p>为了理解Python中赋值语句，应该始终先读右边。对象在右边创建或获取，之后左边的变量才会绑定到对象上。</p>
<h2 id="8-2-标识、相等性和别名"><a href="#8-2-标识、相等性和别名" class="headerlink" title="8.2 标识、相等性和别名"></a>8.2 标识、相等性和别名</h2><p>变量不过是标注，所以对象可以被贴上多个标注，这些多个标注就是<strong>别名</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="string">'name'</span>: <span class="string">'Charles'</span>&#125;</span><br><span class="line">b = a </span><br><span class="line">b <span class="keyword">is</span> a <span class="comment"># true, they have same id</span></span><br><span class="line">c = &#123;<span class="string">'name'</span>: <span class="string">'Charles'</span>&#125;</span><br><span class="line">c == a <span class="comment"># true</span></span><br><span class="line">c <span class="keyword">is</span> a <span class="comment"># false</span></span><br></pre></td></tr></table></figure>
<p><code>==</code>比较值，而<code>is</code>比较标识。通常我们关注值，所以<code>==</code>的使用比较多。但是在变量和单例值之间比较时，应该使用<code>is</code>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line">x <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure></p>
<p><code>is</code>速度比较快，因为不能重载。而<code>a==b</code>等同于<code>a.__eq__(b)</code>.</p>
<blockquote>
<p>每个变量都有标识、类型和值。对象一旦创建，它的标识就不会变；可以把标识看作对象在内存中的地址。 <code>is</code>运算符比较两个对象的标识；<code>id()</code>函数返回对对象标识的整数表示。</p>
</blockquote>
<h3 id="元组的相对不可变性"><a href="#元组的相对不可变性" class="headerlink" title="元组的相对不可变性"></a>元组的相对不可变性</h3><p>元组保存的是对象的引用，如果引用的元素可变，即使元组本身不可变，元素依然可变。</p>
<blockquote>
<p>元组的不可变性其实是指tuple数据结构的物理内容（即保存的引用）不可变，与引用的对象无关。</p>
</blockquote>
<p><img src="/images/blogs/FluentPython/tuple.gif" alt></p>
<h2 id="8-3-默认做浅复制"><a href="#8-3-默认做浅复制" class="headerlink" title="8.3 默认做浅复制"></a>8.3 默认做浅复制</h2><p>复制列表（或多数内置的可变集合）最简单的方法是使用内置的类型构造方法：<br><code>l2 = list(l1)</code><br>或者使用简洁的<code>l2 = l1[:]</code>语句。</p>
<p>上述两种方法做的都是<strong>浅复制</strong>，即复制了最外层容器，副本中的元素是源容器中元素的引用。</p>
<p><img src="/images/blogs/FluentPython/copy.gif" alt></p>
<p>对于元组来说，<code>+=</code>创建一个新元组，重新绑定给变量。而对于列表来说，<code>+=</code>是个就地操作，对象不变。</p>
<h3 id="深复制-amp-amp-浅复制"><a href="#深复制-amp-amp-浅复制" class="headerlink" title="深复制 &amp;&amp; 浅复制"></a>深复制 &amp;&amp; 浅复制</h3><p><code>copy</code>模块提供的<code>deepcopy</code>和<code>copy</code>能为任意对象做深复制和浅复制。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">a = &#123;<span class="string">'name'</span>: <span class="string">'english'</span>&#125;</span><br><span class="line">b = copy.copy(a) <span class="comment"># 浅复制</span></span><br><span class="line">c = copy.deepcopy(a) <span class="comment"># 深复制</span></span><br></pre></td></tr></table></figure></p>
<h2 id="8-4-函数的参数作为引用时"><a href="#8-4-函数的参数作为引用时" class="headerlink" title="8.4 函数的参数作为引用时"></a>8.4 函数的参数作为引用时</h2><p>Python唯一支持的参数传递模式是<strong>共享传参</strong>（call by sharing)，指函数的各个形式参数获得实参中的各个引用的副本，也就是说，函数内部的形参是实参的别名。</p>
<p>所以函数可能会修改作为参数传入的可变对象。 –&gt; 避免使用可变对象做参数默认值。</p>
<p><strong>通常使用None作为接受可变对象的参数的默认值</strong>，在类中直接把参数赋值给变量时要注意，是真的需要修改参数，还是可以通过<strong>创建副本</strong>来避免麻烦。</p>
<h2 id="8-5-del和垃圾回收"><a href="#8-5-del和垃圾回收" class="headerlink" title="8.5 del和垃圾回收"></a>8.5 del和垃圾回收</h2><blockquote>
<p>对象绝不会自行销毁；然而，无法得到对象时，可能会被当作垃圾回收。</p>
</blockquote>
<p><code>del</code>语句删除名称，而不是对象。<code>del</code>命令可能会导致对象被当作垃圾回收，但是仅当删除的变量保存的是对象的最后一个引用，或者无法得到对象时。重新绑定也可能会导致对象的引用数量归零，导致对象被销毁。</p>
<p>CPython中使用引用计数来决定是否垃圾回收。当引用计数归零，对象就被销毁。</p>
<h2 id="8-6-弱引用"><a href="#8-6-弱引用" class="headerlink" title="8.6 弱引用"></a>8.6 弱引用</h2><p>弱引用不会增加对象的引用数量，即不会妨碍所指对象（引用的对象目标）被当作垃圾回收。</p>
<p>弱引用在缓存应用中很有用，可以不用因为被缓存引用而始终保存缓存对象。</p>
<p><code>weakfer</code>模块中的<code>ref</code>（底层接口，供高级用途）、<code>WeakValueDictionary</code>、<code>WeakKeyDictionary</code>、<code>WeakSet</code>是常用集合</p>
<h2 id="8-7-Python对不可变类型施加的把戏"><a href="#8-7-Python对不可变类型施加的把戏" class="headerlink" title="8.7 Python对不可变类型施加的把戏"></a>8.7 Python对不可变类型施加的把戏</h2><p>对元组<code>t</code>来说，<code>t[:]</code>不创建副本，而是返回同一个对象的引用，<code>tuple(t)</code>也是如此。<br><code>str</code>,<code>bytes</code>和<code>frozenset</code>实例也有这种行为。<code>frozenset</code>实例不是序列，不能使用<code>[:]</code>，但是<code>frozenset.copy()</code>具有同样的效果。</p>
<p>共享字符串字面量称为<strong>驻留</strong>，Cpython还会在小的整数上使用这个策略，防止重复创建，如0、-1、42. 所以比较字符串和整数是否相等时应使用<code>==</code>。</p>
<h2 id="8-8-小结"><a href="#8-8-小结" class="headerlink" title="8.8 小结"></a>8.8 小结</h2><ul>
<li>简单的赋值不创建副本</li>
<li><code>+=</code>和<code>*=</code>的具体含义视左边的变量而变，如果不可变对象会创建新对象</li>
<li>对现有的变量赋新值，不会修改之前绑定的变量，这叫做重新绑定。如果变量是之前对象的最后一个引用，对象会被回收</li>
<li>函数的参数以别名的形式传递。所以函数可能会修改传入的可变对象。</li>
<li>使用可变对象作为函数的参数默认值有危险，如果就地修改了参数，默认值就改变了，会影响以后默认值的使用。</li>
</ul>
<h1 id="Chap-9-符合Python风格的对象"><a href="#Chap-9-符合Python风格的对象" class="headerlink" title="Chap 9 符合Python风格的对象"></a>Chap 9 符合Python风格的对象</h1><h2 id="9-1-对象表示形式"><a href="#9-1-对象表示形式" class="headerlink" title="9.1 对象表示形式"></a>9.1 对象表示形式</h2><ul>
<li>repr() –&gt; __repr__<br>以便于开发者理解的方式返回对象的字符串表示形式</li>
<li>str()  –&gt; __str__<br>以便于用户理解的方式返回对象的字符串表示形式</li>
</ul>
<p>此外还有两个特殊方法：</p>
<ul>
<li>__bytes__: bytes()函数调用它获取对象的字节序列表示形式</li>
<li>__format__： 被内置的format()函数和str.format()方法调用，使用特殊的格式代码显示对象的字符串表示形式</li>
</ul>
<h2 id="9-4-classmethod-与-staticmethod"><a href="#9-4-classmethod-与-staticmethod" class="headerlink" title="9.4 classmethod 与 staticmethod"></a>9.4 classmethod 与 staticmethod</h2><p><strong>classmethod</strong>定义操作类，而不是操作实例方法。类方法的第一个参数是类本身，而不是实例。按照约定，类方法的第一个参数名为<code>cls</code>。</p>
<blockquote>
<p><code>self</code>表示一个具体的实例本身<br>  <code>cls</code>表示类本身</p>
</blockquote>
<p><strong>staticmethod</strong>和<code>classmethod</code>非常的相似，但是不强制要求传递参数。它的本质是普通函数，但它不关注对象和对象内部属性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://stackoverflow.com/questions/12179271/meaning-of-classmethod-and-staticmethod-for-beginner </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, day=<span class="number">0</span>, month=<span class="number">0</span>, year=<span class="number">0</span>)</span>:</span></span><br><span class="line">        self.day = day</span><br><span class="line">        self.month = month</span><br><span class="line">        self.year = year</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_string</span><span class="params">(cls, date_as_string)</span>:</span></span><br><span class="line">        day, month, year = map(int, date_as_string.split(<span class="string">'-'</span>))</span><br><span class="line">        date1 = cls(day, month, year)</span><br><span class="line">        <span class="keyword">return</span> date1</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_date_valid</span><span class="params">(date_as_string)</span>:</span></span><br><span class="line">        day, month, year = map(int, date_as_string.split(<span class="string">'-'</span>))</span><br><span class="line">        <span class="keyword">return</span> day &lt;= <span class="number">31</span> <span class="keyword">and</span> month &lt;= <span class="number">12</span> <span class="keyword">and</span> year &lt;= <span class="number">3999</span></span><br><span class="line"></span><br><span class="line">date2 = Date.from_string(<span class="string">'11-09-2012'</span>)</span><br><span class="line">is_date = Date.is_date_valid(<span class="string">'11-09-2012'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="9-5-格式化显示"><a href="#9-5-格式化显示" class="headerlink" title="9.5 格式化显示"></a>9.5 格式化显示</h2><p>内置的<code>format()</code>函数和<code>str.format()</code>方法把哥哥类型的格式化方式委托给相应的<code>.__format__(format_spec)</code>方法。<code>format_spec</code>是格式说明符，用于：</p>
<ul>
<li><code>format(my_obj, format_spec)</code>的第二个参数</li>
<li><code>str.format()</code>方法的格式字符串，<code>{}</code>里代换字段中冒号后面的部分。  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brl = <span class="number">1</span>/<span class="number">2.43</span></span><br><span class="line"><span class="string">'1 BRL = &#123;rate:0.2f&#125; USD'</span>.format(rate=brl)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>冒号左边在代换字段句法中是字段名，后面是格式说明符。<br>格式规范微语言是可扩展的。<br>如果类没有定义<code>__format__</code>方法，从object继承的方法会返回<code>str(my_object)</code>。</p>
<h2 id="9-6-可散列化"><a href="#9-6-可散列化" class="headerlink" title="9.6 可散列化"></a>9.6 可散列化</h2><p>使用两个前导下划线（尾部没有或只有一个下划线）把属性标记为私有的。</p>
<p>想要创建可散列的类型，不一定要实现特性和保护实例属性，只需正确的实现<code>__hash__</code>和<code>__eq__</code>即可。但是实例的散列值绝不应该改变。</p>
<h2 id="9-7-Python的私有属性和“受保护的”属性"><a href="#9-7-Python的私有属性和“受保护的”属性" class="headerlink" title="9.7 Python的私有属性和“受保护的”属性"></a>9.7 Python的私有属性和“受保护的”属性</h2><p>通过<code>__variable</code>的形式（尾部最多有一个下划线）命名属性，Python会把属性名存入实例的<code>__dict__</code>属性中，而且会在前面加上一个下划线和类名，如<code>_myClass__variable</code>。这个特性叫<strong>名称改写（name mangling）</strong>。 这是一种安全措施，它的目的是避免意外访问，不能防止故意修改。<br><code>inst1._myClass__variable = 7</code>这种语句能修改实例的私有属性。  </p>
<p>也有程序员们不喜欢这种写法，他们约定使用一个下划线前缀编写受保护的属性，如<code>self._x</code>。<br>Python解释器不会对单个下划线的属性名做特殊处理，但是程序员们约定不会在类外部访问这种属性。<br>不过如果是模块的话，顶层名称使用一个下划线会有影响：<code>from mymod import *</code>不会用如前缀为下划线的名称，不过可以通过<code>from mymod import _mymod</code>的方式导入。</p>
<h2 id="9-8-使用-slots-类属性节省空间"><a href="#9-8-使用-slots-类属性节省空间" class="headerlink" title="9.8 使用__slots__类属性节省空间"></a>9.8 使用<code>__slots__</code>类属性节省空间</h2><p>Python在默认情况下将实例属性存储在各个实例中名为<code>__dict__</code>的字典里。<br>字典会消耗大量内存。<br>通过<code>__slots__</code>类属性，节省大量内存。  </p>
<p>定义<code>__slots__</code>的方法是：创建一个类属性，使用<code>__slots__</code>这个名字，并把它的值设为一个字符串构成的可迭代对象，其中的元素便是各个实例属性。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myClass</span>:</span></span><br><span class="line">    __slots__ = (<span class="string">'__x'</span>, <span class="string">'__y'</span>)</span><br><span class="line">    <span class="comment"># more codes ...</span></span><br></pre></td></tr></table></figure></p>
<p><code>__slots__</code>属性告诉解释器：这个类中的所有实例属性都在这儿。 这样解释器就会在各个实例中使用类似元组的结构存储实例变量，避免使用<code>__dict__</code>属性。  </p>
<p>在类中定义了<code>__slots__</code>之后，实例中不能有没出现在<code>__slots__</code>中的其他属性。<br>如果在<code>__slots__</code>中添加<code>__dict__</code>，实例会在元组中保存各个实例的属性，还支持动态添加属性，存储在<code>__dict__</code>中。</p>
<p>用户定义的类中默认就有<code>__weakref__</code>属性，如果在类中定义<code>__slots__</code>属性，则要手动添加<code>__weakref__</code>，来让对象支持弱引用。</p>
<p>实例特别多时才推荐使用。</p>
<p><strong>每个子类都要定义<code>__slots__</code>属性，因为继承器会忽略继承的<code>__slots__</code>属性</strong>。</p>
<h2 id="9-9-覆盖类属性"><a href="#9-9-覆盖类属性" class="headerlink" title="9.9 覆盖类属性"></a>9.9 覆盖类属性</h2><p>Python有个独特的特性：类属性可用于为实例属性提供默认值。</p>
<p>如果为不存在的实例属性赋值，会新建实例属性。</p>
<p>类属性是公开的，会被子类继承，因此可以创建一个子类，只用于定制类的数据属性，这样更具Python风格。</p>
<h1 id="Chap-10-序列的修改、散列和切片"><a href="#Chap-10-序列的修改、散列和切片" class="headerlink" title="Chap 10 序列的修改、散列和切片"></a>Chap 10 序列的修改、散列和切片</h1><h2 id="10-3-协议和鸭子类型"><a href="#10-3-协议和鸭子类型" class="headerlink" title="10.3 协议和鸭子类型"></a>10.3 协议和鸭子类型</h2><p>在Python中创建功能完善的序列类型无需使用继承，只需实现符合序列协议的方法。<br>在面向对象编程中，协议是非正式的接口，只在文档中定义，在代码中不定义。例如，Python中的序列协议只需要<code>__len__</code>和<code>__getitem__</code>两个方法。任何类只要使用标准的签名和语义实现了这两个方法，就能用在任何期待序列的地方。</p>
<p>协议是非正式的，没有强制力，因此如果你知道类的具体使用场景，通常只需要实现一个协议的部分。</p>
<h2 id="10-4-切片"><a href="#10-4-切片" class="headerlink" title="10.4 切片"></a>10.4 切片</h2><p>slice中有个<code>indices</code>属性，<code>help(slice.indices)</code>给出的信息：</p>
<blockquote>
<p>S.indices(len) -&gt; (start, stop, stride)<br>给定长度为len的序列，计算S表示的扩展切片的起始和结尾索引，以及步幅。超过边界的索引会被截掉。</p>
</blockquote>
<p>indices将start，end和stride都变成非负数。，而且都落在指定长度序列的边界内。</p>
<h2 id="10-5-动态存取属性"><a href="#10-5-动态存取属性" class="headerlink" title="10.5 动态存取属性"></a>10.5 动态存取属性</h2><p>属性查找失败后，解释器调用<code>__getattr__</code>方法，简单来说，对于<code>my_obj.x</code>表达式，Python会检查<code>my_obj</code>实例有没有名为<code>x</code>的属性；如果没有，到类<code>(my_obj.__class__)</code>中查找；如果还没有，顺着继承树继续查找；如果依旧找不到，就调用<code>my_obj</code>所属类中定义的<code>__getattr__</code>方法，传入<code>self</code>和属性名称的字符串形式。</p>
<h2 id="10-6-散列和快速等值测试"><a href="#10-6-散列和快速等值测试" class="headerlink" title="10.6 散列和快速等值测试"></a>10.6 散列和快速等值测试</h2><h3 id="实现hash方法"><a href="#实现hash方法" class="headerlink" title="实现hash方法"></a>实现<strong>hash</strong>方法</h3><p><code>functools.reduce()</code>可以替换为<code>sum()</code>，关键思想是：把一系列值归约成单个值。</p>
<blockquote>
<p>归约函数(reduce, map, any, all)把序列或有限的可迭代对象变成一个聚合结果</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools, operator</span><br><span class="line"><span class="comment"># 计算0-5的累计异或</span></span><br><span class="line">functools.reduce(operator.xor, range(<span class="number">6</span>))</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line">    <span class="comment"># codes</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__hash__</span><span class="params">(self)</span>:</span></span><br><span class="line">        hashes = (hash(x) <span class="keyword">for</span> x <span class="keyword">in</span> self._components)</span><br><span class="line">        <span class="keyword">return</span> functools.reduce(operator.xor, hashes, <span class="number">0</span>) <span class="comment"># 0是初始值</span></span><br></pre></td></tr></table></figure>
<p><code>reduce</code>函数有个参数，<code>reduce(function, iterable, initializer)</code>，如果序列为空，<code>initializer</code>是返回的结果，否则在归约中使用它作为第一个参数，因此应该使用恒等值。对于<code>+, |, ^</code>来说，应该是0， 对于<code>*, &amp;</code>是1。</p>
<blockquote>
<p><strong>映射归约</strong>：把函数应用到各个元素上，生成一个新的序列（映射，map），然后计算聚合值（归约，reduce）</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__hash__</span><span class="params">(self)</span>:</span></span><br><span class="line">    hashes = map(hash, self._components)</span><br><span class="line">    <span class="keyword">return</span> functools.reduce(operator.xor, hashes)</span><br></pre></td></tr></table></figure>
<h3 id="实现eq方法"><a href="#实现eq方法" class="headerlink" title="实现eq方法"></a>实现<strong>eq</strong>方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> tuple(self) == tuple(other)</span><br></pre></td></tr></table></figure>
<p>这个方法复制两个操作数，构建两个元组进行比较，使用tuple类型的<code>__eq__</code>方法。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(self) != len(other):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> a, b <span class="keyword">in</span> zip(self, other):</span><br><span class="line">        <span class="keyword">if</span> a != b:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure></p>
<p><code>zip</code>函数生成一个由元组构成的生成器。必须先比较长度，因为<code>zip</code>一旦有一个输入耗尽，就会立即停止生成值，而且不会抛出异常。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> len(self) == len(other) <span class="keyword">and</span> all(a == b <span class="keyword">for</span> a,b <span class="keyword">in</span> zip(self, other))</span><br></pre></td></tr></table></figure></p>
<h1 id="Chap-11-接口-从协议到抽象基类"><a href="#Chap-11-接口-从协议到抽象基类" class="headerlink" title="Chap 11 接口: 从协议到抽象基类"></a>Chap 11 接口: 从协议到抽象基类</h1><p>本章讨论从鸭子类型的代表特征动态协议到使接口更明确、能验证实现是否符合规定的抽象基类。</p>
<h2 id="11-1-Python文化中的接口和协议"><a href="#11-1-Python文化中的接口和协议" class="headerlink" title="11.1 Python文化中的接口和协议"></a>11.1 Python文化中的接口和协议</h2><p>Python语言中没有interface关键字，而且除了抽象基类，每个类都有接口：类实现或继承的公开属性（方法或数据属性），包括特殊方法，如<code>__getitem__</code>.<br>按照<strong>定义</strong>，受保护的属性和私有属性不在接口中：即便只是采用命名约定实现“保护”；私有属性可以轻松地访问。</p>
<p>关于接口，有个实用的补充定义：对象公开方法的子集，让对象在系统中扮演特定的角色。</p>
<p>接口是实现特定角色的方法集合。  </p>
<p>协议和继承没有关系。</p>
<p>一个类会实现多个接口，从而让实例扮演多个角色。</p>
<p>协议是接口，但不是正式的，只由文档和约定定义。  </p>
<p>一个类可能只实现部分接口。</p>
<h2 id="11-2-Python喜欢序列"><a href="#11-2-Python喜欢序列" class="headerlink" title="11.2 Python喜欢序列"></a>11.2 Python喜欢序列</h2><p>序列协议是Python最基础的协议之一，即使对象只实现了那个协议最基本的一部分，解释器也会负责地处理。</p>
<p>Python会特殊对待<em>看起来</em>像是序列的对象。</p>
<h2 id="11-3-猴子补丁"><a href="#11-3-猴子补丁" class="headerlink" title="11.3 猴子补丁"></a>11.3 猴子补丁</h2><p>猴子补丁：在运行时修改类或模块，而不改动源码。打补丁的代码要和打补丁的程序耦合紧密，所以需要处理隐藏和没有文档的部分。</p>
<h2 id="11-4-抽象基类"><a href="#11-4-抽象基类" class="headerlink" title="11.4 抽象基类"></a>11.4 抽象基类</h2><p>By Alex Martelli<br>鸭子类型是指忽略对象的真正类型，转而关注对象有没有实现所需的方法、签名和语义。对Python来说，这基本上避免使用<code>isinstance</code>检查对象的类型。  </p>
<p>白鹅类型是指，只要cls是抽象基类，即cls的元类是<code>abc.ABCMeta</code>，就可以使用<code>isinstance(obj, cls)</code>。  </p>
<p>抽象基类可以在代码中使用<code>register</code>类方法把某个类“声明”为一个抽象基类的“虚拟”子类，被注册的类要求满足抽象基类对方法名称和签名的要求，最重要的是满足底层语义契约。<br>有时甚至不需要注册，抽象基类也能识别子类。</p>
<h2 id="11-5-抽象子类的子类"><a href="#11-5-抽象子类的子类" class="headerlink" title="11.5 抽象子类的子类"></a>11.5 抽象子类的子类</h2><p>导入时，Python不会检查子类中抽象方法的实现，在运行时实例化子类才会真正检查。</p>
<p>在<code>collections.abc</code>中，每个抽象基类的具体方法都是作为类的公开接口实现的，因此不用知道实例的内部结构。</p>
<h2 id="11-7-抽象基类定义与使用"><a href="#11-7-抽象基类定义与使用" class="headerlink" title="11.7 抽象基类定义与使用"></a>11.7 抽象基类定义与使用</h2><h3 id="虚拟子类"><a href="#虚拟子类" class="headerlink" title="虚拟子类"></a>虚拟子类</h3><p>注册虚拟子类的方法是在抽象基类上调用<code>register</code>方法，注册的类会变成抽象基类的虚拟子类，而且<code>issubclass</code>和<code>isinstance</code>等函数都能识别。<strong>但是注册的类不会从抽象基类中继承任何方法和属性</strong>（不会被检查）。<br>为了避免运行时错误，虚拟子类要实现所需的全部方法。<br>注册虚拟子类可以使用类装饰器，单更常用的是把它当作函数使用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tombola <span class="keyword">import</span> Tombola</span><br><span class="line"></span><br><span class="line"><span class="meta">@Tombola.register</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TomboList</span><span class="params">(list)</span>:</span></span><br><span class="line">    <span class="comment"># codes...</span></span><br><span class="line"></span><br><span class="line">Sequence.register(str)</span><br></pre></td></tr></table></figure>
<p>类的继承关系在一个特殊的类属性中指定——<code>__mro__</code>，它会列出“真实”的超类，不会显示虚拟注册的基类。</p>
<h2 id="11-11-小结"><a href="#11-11-小结" class="headerlink" title="11.11 小结"></a>11.11 小结</h2><p><strong>不要自己定义抽象基类</strong></p>
<p><strong>不要过度使用抽象基类</strong></p>
<h1 id="Chap-12-继承的优缺点"><a href="#Chap-12-继承的优缺点" class="headerlink" title="Chap 12 继承的优缺点"></a>Chap 12 继承的优缺点</h1><h2 id="12-1-子类化内置类型"><a href="#12-1-子类化内置类型" class="headerlink" title="12.1 子类化内置类型"></a>12.1 子类化内置类型</h2><p>内置类型（使用C语言编写）不会调用用户定义的类覆盖的特殊方法。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoppelDict</span><span class="params">(dict)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        super().__setitem__(key, [value] * <span class="number">2</span>)</span><br><span class="line">dd = DoppelDict(one=<span class="number">1</span>)</span><br><span class="line">dd[<span class="string">'two'</span>] = <span class="number">2</span> <span class="comment"># dd为&#123;'one':1, 'two':[2,2]&#125;</span></span><br><span class="line">dd.update(three=<span class="number">3</span>) <span class="comment"># dd为&#123;'three': 3,'one':1, 'two':[2,2]&#125;</span></span><br><span class="line"><span class="comment"># 不会使用我们覆盖的__setitem__方法</span></span><br></pre></td></tr></table></figure></p>
<p>这样违背了面向对象编程的一个基本原则: 始终从实例（self）所属的类开始搜索方法，即使在超类实现的类中调用也是如此。<br>直接子类化内置类型容易出错，用户自己定义的类应该继承<code>collections</code>模块中的类，比如<code>UserDict</code>, <code>UserList</code>和<code>UserString</code>。</p>
<h2 id="12-2-多重继承和方法解析顺序"><a href="#12-2-多重继承和方法解析顺序" class="headerlink" title="12.2 多重继承和方法解析顺序"></a>12.2 多重继承和方法解析顺序</h2><p>如果同级别的超类定义了同名属性，Python如何确定选择哪一个？这种冲突称为“菱形问题”。<br><img src="/images/blogs/FluentPython/diamond-uml.png" alt><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ping</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'ping:'</span>, self)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pong</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'pong:'</span>, self)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pong</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'PONG:'</span>, self)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(B, C)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ping</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().ping()</span><br><span class="line">        print(<span class="string">'post-ping:'</span>, self)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pingpong</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.ping()</span><br><span class="line">        super().ping()</span><br><span class="line">        self.pong()</span><br><span class="line">        super().pong()</span><br><span class="line">        C.pong(self)</span><br></pre></td></tr></table></figure></p>
<p>B和C都实现了<code>pong()</code>，区别是输出的大小写不同。<br><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> d =D()</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> d.ping()</span></span><br><span class="line">ping: &lt;__main__.D object at 0x0000019678ED55C0&gt;</span><br><span class="line">post-ping: &lt;__main__.D object at 0x0000019678ED55C0&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> d.pong()</span></span><br><span class="line">pong: &lt;__main__.D object at 0x0000019678ED55C0&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> d.pingpong()</span></span><br><span class="line">ping: &lt;__main__.D object at 0x0000019678ED55C0&gt;</span><br><span class="line">post-ping: &lt;__main__.D object at 0x0000019678ED55C0&gt;</span><br><span class="line">ping: &lt;__main__.D object at 0x0000019678ED55C0&gt;</span><br><span class="line">pong: &lt;__main__.D object at 0x0000019678ED55C0&gt;</span><br><span class="line">pong: &lt;__main__.D object at 0x0000019678ED55C0&gt;</span><br><span class="line">PONG: &lt;__main__.D object at 0x0000019678ED55C0&gt;</span><br></pre></td></tr></table></figure></p>
<p>直接运行<code>d.pong()</code>运行的是类B中的代码。在类D中的<code>self.pong()</code>也是B中的代码。<br>这是因为Python会根据<strong>方法解析顺序</strong>来遍历继承图。<br><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> D.__mro__</span></span><br><span class="line">(__main__.D, __main__.B, __main__.C, __main__.A, object)</span><br></pre></td></tr></table></figure></p>
<p>如果想把方法调用委托给超类，推荐使用内置的<code>super()</code>函数。或者直接在类上调用实例方法，此时必须显式传入<code>self</code>参数，因为这样访问的是<em>未绑定方法</em>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(B, C)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ping</span><span class="params">(self)</span>:</span></span><br><span class="line">        A.ping(self)</span><br></pre></td></tr></table></figure></p>
<p>使用<code>super()</code>调用方法时，会遵守方法解析顺序。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pingpong</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.ping() <span class="comment"># 运行D类的ping</span></span><br><span class="line">    super().ping() <span class="comment"># 跳过D类的ping，找到A类的ping</span></span><br><span class="line">    self.pong() <span class="comment"># 根据__mro__，找到B类实现的pong方法</span></span><br><span class="line">    super().pong() <span class="comment"># 同上</span></span><br><span class="line">    C.pong(self) <span class="comment"># 忽略__mro__, 找到C类的pong</span></span><br></pre></td></tr></table></figure></p>
<p>方法解析顺序不仅考虑继承图，还考虑子类声明中列出超类的顺序。如果D的声明为<code>(C, B)</code>，那么D类的<code>__mro__</code>属性就会先是C。</p>
<h2 id="12-4-处理多重继承"><a href="#12-4-处理多重继承" class="headerlink" title="12.4 处理多重继承"></a>12.4 处理多重继承</h2><ol>
<li><strong>把接口继承和实现继承区分开</strong><ul>
<li>继承接口，创建子类型，实现“是什么”的关系</li>
<li>继承实现，通过重用避免代码重复</li>
</ul>
</li>
<li><strong>使用抽象基类显式表示接口</strong></li>
<li><strong>通过混入重用代码</strong><br>如果一个类的作用是为多个不相关的子类提供方法实现，从而实现重用，但不体现“是什么”关系，这个类应明确定义为<strong>混入类(mixin class)</strong>。从概念上讲，混入不定义新类型，只是打包方法，便于重用。混入类绝对不能实例化，而且具体类不能<strong>只</strong>继承混入类。</li>
<li><strong>在名称中明确指明混入</strong><br>在名称中加入<code>...MiXin</code></li>
<li><strong>抽象基类可以作为混入，反之不成立</strong></li>
<li><strong>不要子类化多个具体类</strong><br>具体类可以没有，或最多只有一个具体超类。</li>
<li><strong>为用户提供聚合类</strong><br>如果抽象基类或混入的组合对客户代码非常有用，那就提供一个类，使用便于理解的方式把他们结合起来。</li>
<li><strong>优先使用对象组合，而不是类继承</strong>  </li>
</ol>
<h1 id="Chap-13-正确重载运算符"><a href="#Chap-13-正确重载运算符" class="headerlink" title="Chap 13 正确重载运算符"></a>Chap 13 正确重载运算符</h1><p>运算符重载的作用是让用户定义的对象使用中缀运算符或一元运算符。</p>
<h2 id="13-1-运算符重载基础"><a href="#13-1-运算符重载基础" class="headerlink" title="13.1 运算符重载基础"></a>13.1 运算符重载基础</h2><ul>
<li>不能重载内置类型的运算符</li>
<li>不能新建运算符，只能重载现有的</li>
<li>某些运算符不能重载 —— is, and, or, not（但是位运算符&amp;、|、~可以）</li>
</ul>
<h2 id="13-2-一元运算符"><a href="#13-2-一元运算符" class="headerlink" title="13.2 一元运算符"></a>13.2 一元运算符</h2><ul>
<li>- (__neg__)  一元取负算数运算符</li>
<li><ul>
<li>(__pos__) 一元取正算数运算符，通常<code>x == +x</code>。The unary + (plus) operator yields its numeric argument unchanged.</li>
</ul>
</li>
<li>~ (__invert__) 对整数按位取反，定义为<code>~x == -(x+1)</code></li>
</ul>
<p>这些特殊方法只有一个参数<code>self</code>。<br>遵守运算符的一个规则：始终返回一个新对象，也就是不能修改<code>self</code>，要创建并返回合适类型的新实例。<br>多数时候，<code>+</code>最好返回<code>self</code>的副本。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__abs__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> math.sqrt(sum(x * x <span class="keyword">for</span> x <span class="keyword">in</span> self))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__neg__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> Vector(-x <span class="keyword">for</span> x <span class="keyword">in</span> self)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__pos__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> Vector(self)</span><br></pre></td></tr></table></figure></p>
<h2 id="13-3-重载加法运算符"><a href="#13-3-重载加法运算符" class="headerlink" title="13.3 重载加法运算符+"></a>13.3 重载加法运算符+</h2><p><img src="/images/blogs/FluentPython/flowchart-operator.png" alt><br><code>__radd__</code>是<code>__add__</code>的反向版本，在右操作数上调用。</p>
<p><code>NotImplemented</code>是特殊单例值，而<code>NotImplementedError</code>是一种异常，抽象类中的占位方法把它抛出，提醒子类必须覆盖。</p>
<p>如果由于类型不兼容而导致运算符特殊方法无法返回有效结果时，应返回<code>NotImplemented</code>，而不是<code>TypeError</code>，这样另一个操作数所属的类型还有机会执行运算，即反向运算。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        pairs = itertools.zip_longest(self, other, fillvalue = <span class="number">0.0</span>)</span><br><span class="line">        <span class="keyword">return</span> Vector(a + b <span class="keyword">for</span> a, b <span class="keyword">in</span> pairs)</span><br><span class="line">    <span class="keyword">except</span> TypeError:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__radd__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self + other <span class="comment"># radd 直接委托 add</span></span><br></pre></td></tr></table></figure>
<h2 id="13-4-重载标量乘法运算符"><a href="#13-4-重载标量乘法运算符" class="headerlink" title="13.4 重载标量乘法运算符 *"></a>13.4 重载标量乘法运算符 *</h2><p>Python中的<code>*</code>为标量积，各个分量会乘以后面的数字，也叫元素级乘法。<br>对于乘法来说，需要考虑操作数类型不兼容的问题。在加法重载中，使用了鸭子类型，捕获<code>TypeError</code>。在这里，可以使用<strong>白鹅类型</strong>，使用<code>isinstance()</code>检查类型，但是不硬编码具体的类型，而检查<code>numbers.Real</code>抽象基类。这个抽象基类覆盖我们所需的类型，而且可以兼容后续被声明为该抽象基类的真实/虚拟子类的数值类型。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__mul__</span><span class="params">(self, scalar)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(scalar, numbers.Real):</span><br><span class="line">        <span class="keyword">return</span> Vector(n * scalar <span class="keyword">for</span> n <span class="keyword">in</span> self)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__rmul__</span><span class="params">(self, scalar)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self * scalar</span><br></pre></td></tr></table></figure>
<p><strong>点乘</strong>，在<code>Numpy</code>中使用<code>numpy.dot()</code>函数计算，Python3.5引入<code>@</code>中缀运算符来计算点积。</p>
<h2 id="13-5-众多比较运算符"><a href="#13-5-众多比较运算符" class="headerlink" title="13.5 众多比较运算符"></a>13.5 众多比较运算符</h2><ul>
<li>正向和反向调用使用同一系列方法。</li>
<li>对<code>==</code>和<code>!=</code>来说，如果反向调用失败，Python会比较对象的id，而不抛出TypeError</li>
</ul>
<p>Python3 之后对于<code>__ne__</code>，返回对<code>__eq__</code>结果的取反。</p>
<h2 id="13-6-增量赋值运算符"><a href="#13-6-增量赋值运算符" class="headerlink" title="13.6 增量赋值运算符"></a>13.6 增量赋值运算符</h2><p>如果一个类没有实现就地运算符，增量赋值运算只是语法糖：<code>a+=b</code>等同于<code>a=a+b</code>。如果定义了<code>__add__</code>，<code>+=</code>也能使用。<br>如果实现了就地运算符，就会就地修改左操作数，不会创建新的对象。但是对于不可变类型来说，这个运算符依然等同于语法糖。</p>
<p>与<code>+</code>相比，<code>+=</code>对第二个操作数更宽容。</p>
<h2 id="13-7-小结"><a href="#13-7-小结" class="headerlink" title="13.7 小结"></a>13.7 小结</h2><p>对于操作数类型来说，有两种处理方法：</p>
<ul>
<li>鸭子类型，直接执行运算，如果有问题再抛出TypeError异常</li>
<li>白鹅类型，通过显示检查抽象基类来得到类型结果</li>
</ul>
<h1 id="Chap-14-可迭代的对象、迭代器和生成器"><a href="#Chap-14-可迭代的对象、迭代器和生成器" class="headerlink" title="Chap 14 可迭代的对象、迭代器和生成器"></a>Chap 14 可迭代的对象、迭代器和生成器</h1><h2 id="14-1-序列可迭代的原因：iter函数"><a href="#14-1-序列可迭代的原因：iter函数" class="headerlink" title="14.1 序列可迭代的原因：iter函数"></a>14.1 序列可迭代的原因：iter函数</h2><p>解释器迭代对象x时，会调用<code>iter(x)</code>。内置的<code>iter</code>函数有以下作用：</p>
<ol>
<li>检查对象是否实现<code>__iter__</code>方法，如果实现了就调用，获取一个迭代器</li>
<li>如果没有实现<code>__iter__</code>，但是实现了<code>__getitem__</code>，Python会创建一个迭代器，尝试按顺序（从索引0开始）获取元素</li>
<li>如果尝试失败，Python抛出TypeError异常。</li>
</ol>
<!-- Python 3.4之后，检查对象是否可迭代，应该调用`iter(x)`，而不是`isinstance(x, abc.Iterable)`。因为前者会考虑到`__getitem__`. -->
<h2 id="14-2-可迭代对象与迭代器的对比"><a href="#14-2-可迭代对象与迭代器的对比" class="headerlink" title="14.2 可迭代对象与迭代器的对比"></a>14.2 可迭代对象与迭代器的对比</h2><blockquote>
<p><strong>可迭代的对象</strong><br>使用<code>iter</code>内置函数可以获取迭代器的对象。如果实现了能返回迭代器的<code>__iter__</code>方法，那么对象就是可迭代的。序列都可以迭代；实现了<code>__getitem__</code>方法，而且参数是从零开始的索引，这种对象也可以迭代。</p>
</blockquote>
<p><strong>Python从可迭代的对象中获取迭代器</strong>。</p>
<p>标准的迭代器接口有两个方法：</p>
<ul>
<li><code>__next__</code><br>返回下一个可用元素，如果没有，抛出<code>StopIteration</code></li>
<li><code>__iter__</code><br>返回<code>self</code>，以便在应该使用可迭代对象的地方使用迭代器。</li>
</ul>
<blockquote>
<p><strong>迭代器</strong><br>实现了无参数的<code>__next__</code>方法， 返回序列中的下一个元素；如果没有就抛出<code>StopIteration</code>。Python中迭代器还实现了<code>__iter__</code>方法，因此迭代器也可以迭代。</p>
</blockquote>
<h2 id="14-4-生成器函数"><a href="#14-4-生成器函数" class="headerlink" title="14.4 生成器函数"></a>14.4 生成器函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> self.words:</span><br><span class="line">        <span class="keyword">yield</span> word</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<p>只要函数的定义体内有<code>yield</code>关键字，这个函数就是生成器函数。调用生成器函数会返回一个生成器对象。也就是说，生成器函数是生成器工厂。</p>
<h2 id="14-5-惰性实现"><a href="#14-5-惰性实现" class="headerlink" title="14.5 惰性实现"></a>14.5 惰性实现</h2><p>惰性求值(laze evaluation)和及早求值(eager evaluation)是两个相反的方法。  </p>
<p><code>re.finditer</code>函数是<code>re.findall</code>的惰性版本，返回的不是一个列表，而是一个生成器，按需生成<code>re.MatchObject</code>实例。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> reprlib</span><br><span class="line"></span><br><span class="line">RE_WORD = re.compile(<span class="string">'\w+'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sentence</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.text = text</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Sentence(%s)'</span> % reprlib.repr(self.text)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> match <span class="keyword">in</span> RE_WORD.finditer(self.text):</span><br><span class="line">            <span class="keyword">yield</span> match.group()</span><br></pre></td></tr></table></figure></p>
<p><code>match.group()</code>方法从MatchObject实例中提取匹配正则表达式的具体文本。</p>
<h2 id="14-6-生成器表达式"><a href="#14-6-生成器表达式" class="headerlink" title="14.6 生成器表达式"></a>14.6 生成器表达式</h2><p>简单的生成器函数可以替换为生成器表达式。<br>生成器表达式可以理解为列表推到的惰性版本：不会迫切的构建列表，而是返回一个生成器，惰性按需生成元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (match.group() <span class="keyword">for</span> match <span class="keyword">in</span> RE_WORD.finditer(self.text))</span><br></pre></td></tr></table></figure>
<p><strong>如果生成器表达式要分成多行写，倾向于定义生成器函数，以便提高可读性。此外，生成器函数有名称，可以重用。</strong></p>
<h2 id="14-9-标准库中的生成器函数"><a href="#14-9-标准库中的生成器函数" class="headerlink" title="14.9 标准库中的生成器函数"></a>14.9 标准库中的生成器函数</h2><blockquote>
<p>p349 - p356</p>
</blockquote>
<blockquote>
<p><code>itertools.dropwhile</code> would stop dropping when failed and take the rest.<br><code>itertools.takewhile</code> wound stop taking when failed and drop the rest.</p>
</blockquote>
<h2 id="14-12-深入分析iter函数"><a href="#14-12-深入分析iter函数" class="headerlink" title="14.12 深入分析iter函数"></a>14.12 深入分析iter函数</h2><p><code>iter</code>函数可以传入两个参数，第一个参数是可调用对象， 用于不断调用，产出各个值；第二个参数是哨符，当可调用对象返回这个值时，触发迭代器抛出<code>StopIteration</code>异常，而<strong>不产出哨符</strong>。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Python/" rel="tag"># Python</a>
          
            <a href="/tags/读书笔记/" rel="tag"># 读书笔记</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/10/14/Fluent-Python-读书笔记-3/" rel="next" title="Fluent Python 读书笔记(3)">
                <i class="fa fa-chevron-left"></i> Fluent Python 读书笔记(3)
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/11/02/Data-Visualization-and-D3-js-笔记-6/" rel="prev" title="Data Visualization and D3.js 笔记(6)">
                Data Visualization and D3.js 笔记(6) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      
        <div onclick="showGitment()" id="gitment-display-button">显示 Gitment 评论</div>
        <div id="gitment-container" style="display:none"></div>
      
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/sfl.jpg" alt="Sun Fuling">
            
              <p class="site-author-name" itemprop="name">Sun Fuling</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Friends
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://ciuji.me/" title="ciuji" target="_blank">ciuji</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://lianqing11.github.io/" title="LianQing" target="_blank">LianQing</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Chap-8-对象引用、可变性和垃圾回收"><span class="nav-number">1.</span> <span class="nav-text">Chap 8 对象引用、可变性和垃圾回收</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#8-1-变量不是盒子"><span class="nav-number">1.1.</span> <span class="nav-text">8.1 变量不是盒子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-2-标识、相等性和别名"><span class="nav-number">1.2.</span> <span class="nav-text">8.2 标识、相等性和别名</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#元组的相对不可变性"><span class="nav-number">1.2.1.</span> <span class="nav-text">元组的相对不可变性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-3-默认做浅复制"><span class="nav-number">1.3.</span> <span class="nav-text">8.3 默认做浅复制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#深复制-amp-amp-浅复制"><span class="nav-number">1.3.1.</span> <span class="nav-text">深复制 &amp;&amp; 浅复制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-4-函数的参数作为引用时"><span class="nav-number">1.4.</span> <span class="nav-text">8.4 函数的参数作为引用时</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-5-del和垃圾回收"><span class="nav-number">1.5.</span> <span class="nav-text">8.5 del和垃圾回收</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-6-弱引用"><span class="nav-number">1.6.</span> <span class="nav-text">8.6 弱引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-7-Python对不可变类型施加的把戏"><span class="nav-number">1.7.</span> <span class="nav-text">8.7 Python对不可变类型施加的把戏</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-8-小结"><span class="nav-number">1.8.</span> <span class="nav-text">8.8 小结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Chap-9-符合Python风格的对象"><span class="nav-number">2.</span> <span class="nav-text">Chap 9 符合Python风格的对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#9-1-对象表示形式"><span class="nav-number">2.1.</span> <span class="nav-text">9.1 对象表示形式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-4-classmethod-与-staticmethod"><span class="nav-number">2.2.</span> <span class="nav-text">9.4 classmethod 与 staticmethod</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-5-格式化显示"><span class="nav-number">2.3.</span> <span class="nav-text">9.5 格式化显示</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-6-可散列化"><span class="nav-number">2.4.</span> <span class="nav-text">9.6 可散列化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-7-Python的私有属性和“受保护的”属性"><span class="nav-number">2.5.</span> <span class="nav-text">9.7 Python的私有属性和“受保护的”属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-8-使用-slots-类属性节省空间"><span class="nav-number">2.6.</span> <span class="nav-text">9.8 使用__slots__类属性节省空间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-9-覆盖类属性"><span class="nav-number">2.7.</span> <span class="nav-text">9.9 覆盖类属性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Chap-10-序列的修改、散列和切片"><span class="nav-number">3.</span> <span class="nav-text">Chap 10 序列的修改、散列和切片</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#10-3-协议和鸭子类型"><span class="nav-number">3.1.</span> <span class="nav-text">10.3 协议和鸭子类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-4-切片"><span class="nav-number">3.2.</span> <span class="nav-text">10.4 切片</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-5-动态存取属性"><span class="nav-number">3.3.</span> <span class="nav-text">10.5 动态存取属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-6-散列和快速等值测试"><span class="nav-number">3.4.</span> <span class="nav-text">10.6 散列和快速等值测试</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#实现hash方法"><span class="nav-number">3.4.1.</span> <span class="nav-text">实现hash方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现eq方法"><span class="nav-number">3.4.2.</span> <span class="nav-text">实现eq方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Chap-11-接口-从协议到抽象基类"><span class="nav-number">4.</span> <span class="nav-text">Chap 11 接口: 从协议到抽象基类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#11-1-Python文化中的接口和协议"><span class="nav-number">4.1.</span> <span class="nav-text">11.1 Python文化中的接口和协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-2-Python喜欢序列"><span class="nav-number">4.2.</span> <span class="nav-text">11.2 Python喜欢序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-3-猴子补丁"><span class="nav-number">4.3.</span> <span class="nav-text">11.3 猴子补丁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-4-抽象基类"><span class="nav-number">4.4.</span> <span class="nav-text">11.4 抽象基类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-5-抽象子类的子类"><span class="nav-number">4.5.</span> <span class="nav-text">11.5 抽象子类的子类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-7-抽象基类定义与使用"><span class="nav-number">4.6.</span> <span class="nav-text">11.7 抽象基类定义与使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#虚拟子类"><span class="nav-number">4.6.1.</span> <span class="nav-text">虚拟子类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-11-小结"><span class="nav-number">4.7.</span> <span class="nav-text">11.11 小结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Chap-12-继承的优缺点"><span class="nav-number">5.</span> <span class="nav-text">Chap 12 继承的优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#12-1-子类化内置类型"><span class="nav-number">5.1.</span> <span class="nav-text">12.1 子类化内置类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-2-多重继承和方法解析顺序"><span class="nav-number">5.2.</span> <span class="nav-text">12.2 多重继承和方法解析顺序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-4-处理多重继承"><span class="nav-number">5.3.</span> <span class="nav-text">12.4 处理多重继承</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Chap-13-正确重载运算符"><span class="nav-number">6.</span> <span class="nav-text">Chap 13 正确重载运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#13-1-运算符重载基础"><span class="nav-number">6.1.</span> <span class="nav-text">13.1 运算符重载基础</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-2-一元运算符"><span class="nav-number">6.2.</span> <span class="nav-text">13.2 一元运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-3-重载加法运算符"><span class="nav-number">6.3.</span> <span class="nav-text">13.3 重载加法运算符+</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-4-重载标量乘法运算符"><span class="nav-number">6.4.</span> <span class="nav-text">13.4 重载标量乘法运算符 *</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-5-众多比较运算符"><span class="nav-number">6.5.</span> <span class="nav-text">13.5 众多比较运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-6-增量赋值运算符"><span class="nav-number">6.6.</span> <span class="nav-text">13.6 增量赋值运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-7-小结"><span class="nav-number">6.7.</span> <span class="nav-text">13.7 小结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Chap-14-可迭代的对象、迭代器和生成器"><span class="nav-number">7.</span> <span class="nav-text">Chap 14 可迭代的对象、迭代器和生成器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#14-1-序列可迭代的原因：iter函数"><span class="nav-number">7.1.</span> <span class="nav-text">14.1 序列可迭代的原因：iter函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-2-可迭代对象与迭代器的对比"><span class="nav-number">7.2.</span> <span class="nav-text">14.2 可迭代对象与迭代器的对比</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-4-生成器函数"><span class="nav-number">7.3.</span> <span class="nav-text">14.4 生成器函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-5-惰性实现"><span class="nav-number">7.4.</span> <span class="nav-text">14.5 惰性实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-6-生成器表达式"><span class="nav-number">7.5.</span> <span class="nav-text">14.6 生成器表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-9-标准库中的生成器函数"><span class="nav-number">7.6.</span> <span class="nav-text">14.9 标准库中的生成器函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-12-深入分析iter函数"><span class="nav-number">7.7.</span> <span class="nav-text">14.12 深入分析iter函数</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sun Fuling</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  







<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css">
        <script src="https://aimingoo.github.io/gitmint/dist/gitmint.browser.js"></script>
    
<!-- END LOCAL -->

    

    
      <script type="text/javascript">
      function renderGitment(){
        var gitment = new Gitmint({
            id: 'Fluent Python 读书笔记(4)', 
            owner: 'soundquiet',
            repo: 'soundquiet.github.io',
            
            lang: "" || navigator.language || navigator.systemLanguage || navigator.userLanguage,
            
            oauth: {
            
            
                client_secret: '262a84fa3d903d2933b70fe9fa90a5db8ed57333',
            
                client_id: 'b604845ecbd0c13cb82d'
            }});
        gitment.render('gitment-container');
      }

      
      function showGitment(){
        document.getElementById("gitment-display-button").style.display = "none";
        document.getElementById("gitment-container").style.display = "block";
        renderGitment();
      }
      
      </script>
    







  





  

  

  

  
  

  

  

  

</body>
</html>
