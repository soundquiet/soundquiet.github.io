<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Soundquiet</title>
  
  <subtitle>Life with studying, coding and ciuji</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://soundquiet.github.io/"/>
  <updated>2018-11-02T13:13:32.000Z</updated>
  <id>https://soundquiet.github.io/</id>
  
  <author>
    <name>Sun Fuling</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Data Visualization and D3.js 笔记(6)</title>
    <link href="https://soundquiet.github.io/2018/11/02/Data-Visualization-and-D3-js-%E7%AC%94%E8%AE%B0-6/"/>
    <id>https://soundquiet.github.io/2018/11/02/Data-Visualization-and-D3-js-笔记-6/</id>
    <published>2018-11-02T13:09:43.000Z</published>
    <updated>2018-11-02T13:13:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>这一节(Lesson 8)实现动画效果。<br><a id="more"></a></p><h1 id="Lesson-8-动画与互动"><a href="#Lesson-8-动画与互动" class="headerlink" title="Lesson 8 动画与互动"></a>Lesson 8 动画与互动</h1><h2 id="地图"><a href="#地图" class="headerlink" title="地图"></a>地图</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul><li>shapefile 二进制</li><li>GeoJSON 可读性，数据多，臃肿</li><li>TopoJSON 拓扑结构</li></ul><h3 id="投影"><a href="#投影" class="headerlink" title="投影"></a>投影</h3><p><strong>墨卡托投影</strong>是一种“等角横轴割圆柱投影”，椭圆柱割地球于南纬80度、北纬84度两条等高圈，投影后两条相割的经线上没有变形，而中央经线上长度比0.9996。<br>墨卡托投影的过程其实非常简单，就是将地球展开成一个圆柱，再将圆柱展开成平面。<br><img src="/images/blogs/dv&amp;d3/lesson8/mercator.jpg" alt></p><h3 id="主题地图"><a href="#主题地图" class="headerlink" title="主题地图"></a>主题地图</h3><ul><li>dot 点，颜色，负空间，eg瘟疫地图</li><li>choropleth 等值线图，根据地区数据进行补色</li><li>cartogram 变形地图，根据数据值改变区域、形状和尺寸</li><li>graduated symbol 符号渐变地图</li></ul><h2 id="利用d3绘制地图"><a href="#利用d3绘制地图" class="headerlink" title="利用d3绘制地图"></a>利用d3绘制地图</h2><h3 id="static-map"><a href="#static-map" class="headerlink" title="static map"></a>static map</h3><p>GeoJSON有很多常见地理区域的数据文件，可以直接使用。<br>d3内置函数<code>json()</code>可以载入JSON文件<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d3.json(<span class="string">'world_countries.json'</span>, draw);</span><br></pre></td></tr></table></figure></p><h4 id="从SVG路径绘制地图"><a href="#从SVG路径绘制地图" class="headerlink" title="从SVG路径绘制地图"></a>从SVG路径绘制地图</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params">geo_data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">var</span> projection = d3.geo.mercator();<span class="comment">//墨卡托投影法</span></span><br><span class="line">    <span class="comment">// 类似于用scale将整数或浮点数转换成像素点的映射</span></span><br><span class="line">    <span class="comment">// 把经度和维度转换为像素域</span></span><br><span class="line">    <span class="keyword">var</span> path = d3.geo.path.projection(projection);</span><br><span class="line">    <span class="comment">// 构建SVG对象来正确呈现这些像素</span></span><br><span class="line">    <span class="keyword">var</span> map = d3.selectAll(<span class="string">'path'</span>) <span class="comment">//空选择</span></span><br><span class="line">                .data(geo_data.features) <span class="comment">// 检查geo_data，了解其数据结构，.features与国家坐标的数组相对应</span></span><br><span class="line">                .enter()</span><br><span class="line">                .append(<span class="string">'path'</span>)</span><br><span class="line">                .attr(<span class="string">'d'</span>, path) <span class="comment">// 将d属性设置为上面创建的路径对象；将顶点或值填在d属性中，认为是路径是数据，指定SVG路径用于绘图</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="绘制并更改地图"><a href="#绘制并更改地图" class="headerlink" title="绘制并更改地图"></a>绘制并更改地图</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> projection = d3.geo.mercator()</span><br><span class="line">                        .sacle(<span class="number">170</span>) <span class="comment">// 取得或设置投影的缩放系数</span></span><br><span class="line">                        .translate([width / <span class="number">2</span>, height / <span class="number">2</span>]); <span class="comment">//取得或设置投影的平移位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> map = d3.selectAll(<span class="string">'path'</span>)</span><br><span class="line">                .data(geo_data.features)</span><br><span class="line">                .enter()</span><br><span class="line">                .append(<span class="string">'path'</span>)</span><br><span class="line">                .attr(<span class="string">'d'</span>, path)</span><br><span class="line">                .style(<span class="string">'fill'</span>, <span class="string">'lightBlue'</span>)</span><br><span class="line">                .style(<span class="string">'stroke'</span>, <span class="string">'black'</span>)</span><br><span class="line">                .style(<span class="string">'stroke-width'</span>, <span class="number">0.5</span>)</span><br></pre></td></tr></table></figure><p><img src="/images/blogs/dv&amp;d3/lesson8/worldcup1.png" alt></p><h3 id="bubble-map"><a href="#bubble-map" class="headerlink" title="bubble map"></a>bubble map</h3><p>为地图添加表示主办国的circle.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params">geo_data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">plot_points</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">var</span> format = d3.time.format(<span class="string">'%d-%m-%T (%H:%M h)'</span>)</span><br><span class="line">    d3.tsv(<span class="string">'world_cup_geo.tsv'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">        d.attentance = +d.attentance;</span><br><span class="line">        d.date = format.parse(d.date); </span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;, plot_points);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="d3的嵌套Nest"><a href="#d3的嵌套Nest" class="headerlink" title="d3的嵌套Nest"></a>d3的嵌套Nest</h4><blockquote><p>嵌套允许数组中的元素被组织为分层树型结构；类似SQL语句里面的GROUP BY方法，但不能多级别分组，而且输出的结果是树而不是一般的表。树的层级由key方法指定。树的叶节点可以按值来排序，而内部节点可以按键来排序。可选参数汇总（rollup）函数可以使用加法函数瓦解每个叶节点的元素. nest 操作符(d3.nest返回的对象)是可以重复使用的，不保留任何嵌套数据的引用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> yields = [&#123;<span class="attr">yield</span>: <span class="number">27.00</span>, <span class="attr">variety</span>: <span class="string">"Manchuria"</span>, <span class="attr">year</span>: <span class="number">1931</span>, <span class="attr">site</span>: <span class="string">"University Farm"</span>&#125;,</span><br><span class="line">              &#123;<span class="attr">yield</span>: <span class="number">48.87</span>, <span class="attr">variety</span>: <span class="string">"Manchuria"</span>, <span class="attr">year</span>: <span class="number">1931</span>, <span class="attr">site</span>: <span class="string">"Waseca"</span>&#125;,</span><br><span class="line">              &#123;<span class="attr">yield</span>: <span class="number">27.43</span>, <span class="attr">variety</span>: <span class="string">"Manchuria"</span>, <span class="attr">year</span>: <span class="number">1931</span>, <span class="attr">site</span>: <span class="string">"Morris"</span>&#125;, </span><br><span class="line">              ...]</span><br><span class="line"><span class="keyword">var</span> nest = d3.nest()</span><br><span class="line">            .key(<span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123; <span class="keyword">return</span> d.years; &#125;)</span><br><span class="line">            .key(<span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123; <span class="keyword">return</span> d.variety; &#125;)</span><br><span class="line">            .entries(yields);</span><br></pre></td></tr></table></figure></p></blockquote><p>返回的嵌套数组中。每个元素的外部数组是键-值对，列出每个不同键的值:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[&#123;<span class="attr">key</span>: <span class="number">1931</span>, <span class="attr">values</span>: [</span><br><span class="line">    &#123;<span class="attr">key</span>: <span class="string">"Manchuria"</span>, <span class="attr">values</span>: [</span><br><span class="line">        &#123;<span class="attr">yield</span>: <span class="number">27.00</span>, <span class="attr">variety</span>: <span class="string">"Manchuria"</span>, <span class="attr">year</span>: <span class="number">1931</span>, <span class="attr">site</span>: <span class="string">"University Farm"</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">yield</span>: <span class="number">48.87</span>, <span class="attr">variety</span>: <span class="string">"Manchuria"</span>, <span class="attr">year</span>: <span class="number">1931</span>, <span class="attr">site</span>: <span class="string">"Waseca"</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">yield</span>: <span class="number">27.43</span>, <span class="attr">variety</span>: <span class="string">"Manchuria"</span>, <span class="attr">year</span>: <span class="number">1931</span>, <span class="attr">site</span>: <span class="string">"Morris"</span>&#125;, ...]&#125;,</span><br><span class="line">    &#123;<span class="attr">key</span>: <span class="string">"Glabron"</span>, <span class="attr">values</span>: [</span><br><span class="line">        &#123;<span class="attr">yield</span>: <span class="number">43.07</span>, <span class="attr">variety</span>: <span class="string">"Glabron"</span>, <span class="attr">year</span>: <span class="number">1931</span>, <span class="attr">site</span>: <span class="string">"University Farm"</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">yield</span>: <span class="number">55.20</span>, <span class="attr">variety</span>: <span class="string">"Glabron"</span>, <span class="attr">year</span>: <span class="number">1931</span>, <span class="attr">site</span>: <span class="string">"Waseca"</span>&#125;, ...]&#125;, ...]&#125;,</span><br><span class="line"> &#123;<span class="attr">key</span>: <span class="number">1932</span>, <span class="attr">values</span>: ...&#125;]</span><br></pre></td></tr></table></figure></p><p><code>d3.nest()</code>创建一个新的操作符，keys集合初始为空。如果map或entries操作符在任何键函数<code>key</code>被注册之前被调用，这个嵌套操作符通常返回输入数组。</p><p><code>nest.key(function)</code>注册一个新的键函数function，键函数将被输入数组中的每个函数调用，并且必须返回一个用于分配元素到它的组内的字符串标识符。通常，这个函数被实现为一个简单的访问器，如上面例子中year和variety的访问器。 输入的数组的引导（index）并没有传递给function。每当一个key 被注册，它被放到一个内部键数组的末端，和由此产生的map或实体将有一个额外的层级。当前没有一个方法可以删除或查询注册的键。最近注册的键在后续的方法中被当作当前键。</p><p><code>nest.rollup(function)</code>为每组中的叶子元素指定汇总函数（rollup）function。<strong>汇总函数的返回值会覆盖叶子值数组</strong>。不论是由map操作符返回的关联数组，还是实体操作符返回的每个实体的值属性。</p><p><code>nest.map(array[, mapType])</code>对指定的数组使用nest操作符，返回一个关联数组。返回的关联数组array中每个实体对应由第一个key函数返回的不同的key值。实体值决定于注册的key函数的数量：如果有一个额外的key，值就是另外一个嵌套的关联数组；否则，值就是过滤自含有指定key值得输入数组array的元素数组。</p><p><code>nest.entries(array)</code>为指定的array参数应用nest操作符，返回一个键值对数组。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">plot_points</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> nested = d3.nest()</span><br><span class="line">                    .key(<span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> d.date.getUTCFullYear();</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .rollup(<span class="function"><span class="keyword">function</span>(<span class="params">leaves</span>) </span>&#123;</span><br><span class="line">                        <span class="keyword">var</span> total = d3.sum(leaves, <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">                            <span class="keyword">return</span> d.attendance;</span><br><span class="line">                        &#125;);</span><br><span class="line">                        <span class="keyword">var</span> coords = leaves.map(<span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">                            <span class="keyword">return</span> projection([+d.long, +d.lat]);</span><br><span class="line">                        &#125;);</span><br><span class="line">                        <span class="keyword">var</span> center_X = d3.mean(coords, <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">                            <span class="keyword">return</span> d[<span class="number">0</span>];</span><br><span class="line">                        &#125;);</span><br><span class="line">                        <span class="keyword">var</span> center_Y = d3.mean(coords, <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">                            <span class="keyword">return</span> d[<span class="number">1</span>];</span><br><span class="line">                        &#125;);</span><br><span class="line">                        <span class="keyword">return</span> &#123;</span><br><span class="line">                            <span class="string">'attendance'</span>: total,</span><br><span class="line">                            <span class="string">'x'</span>: center_X,</span><br><span class="line">                            <span class="string">'y'</span>: center_Y</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .entries(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>nested</code>返回的是包含20个元素的数组，这20个元素对应世界杯的举办次数。每个元素的key值为年份，values值是attendance和x与y坐标。</p><h4 id="添加圆圈"><a href="#添加圆圈" class="headerlink" title="添加圆圈"></a>添加圆圈</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">svg.append(<span class="string">'g'</span>)</span><br><span class="line">    .attr(<span class="string">'class'</span>, <span class="string">'bubble'</span>)</span><br><span class="line">    .selectAll(<span class="string">'circle'</span>)</span><br><span class="line">    .data(nested)</span><br><span class="line">    .enter()</span><br><span class="line">    .append(<span class="string">'circle'</span>)</span><br><span class="line">    .attr(<span class="string">'cx'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> d.values.x;</span><br><span class="line">    &#125;)</span><br><span class="line">    .attr(<span class="string">'cy'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> d.values.y;</span><br><span class="line">    &#125;)</span><br><span class="line">    .attr(<span class="string">'r'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> radius(d.values[<span class="string">'attendance'</span>]);</span><br><span class="line">    &#125;)</span><br><span class="line">    .style(<span class="string">'stroke'</span>, <span class="string">'black'</span>)</span><br><span class="line">    .style(<span class="string">'stroke-width'</span>, <span class="number">0.7</span>)</span><br><span class="line">    .style(<span class="string">'fill'</span>, <span class="string">'rgb(247,148,32)'</span>)</span><br><span class="line">    .style(<span class="string">'opacity'</span>, <span class="number">0.7</span>);</span><br></pre></td></tr></table></figure><p>使用圆圈表达数据时，需要注意，圆圈表示的数据是<strong>半径的平方</strong>。<br>要避免这个问题，数据值应匹配圆圈的面积。可以将数据值开平方，以确定每个圆圈的半径。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> attendance_max = d3.max(nested, <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> d.values.attendance;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> radius = d3.scale.sqrt()</span><br><span class="line">                .domain([<span class="number">0</span>, attendance_max])</span><br><span class="line">                .range([<span class="number">0</span>, <span class="number">15</span>]);</span><br></pre></td></tr></table></figure></p><h4 id="就绘图顺序对数据进行排序"><a href="#就绘图顺序对数据进行排序" class="headerlink" title="就绘图顺序对数据进行排序"></a>就绘图顺序对数据进行排序</h4><p>不干预数据的绘制顺序，可能会出现大圆遮挡小圆的情况。通过数据分类，我们能避免这种情况。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">svg.append(<span class="string">'g'</span>)</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    .data(nested.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b.values.attendance &gt; a.values.attendance;</span><br><span class="line">    &#125;))</span><br></pre></td></tr></table></figure></p><p><img src="/images/blogs/dv&amp;d3/lesson8/worldcup2.png" alt></p><h3 id="author-driven-narrative-animation"><a href="#author-driven-narrative-animation" class="headerlink" title="author driven narrative (animation)"></a>author driven narrative (animation)</h3><p>当前的设计为了保留空间信息而丢失了时间信息。</p><p>动画可以传达变化的时间数据。</p><h4 id="更新函数"><a href="#更新函数" class="headerlink" title="更新函数"></a>更新函数</h4><p><code>update</code>函数应该做到：</p><ol><li>filter data <code>filter</code></li><li>remove any elements which no longer belong there <code>.exit()</code></li><li>add any new elements <code>.enter()</code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">key_func</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> d.key;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params">year</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 过滤得到指定年份的数据</span></span><br><span class="line">    <span class="keyword">var</span> filter = nested.filter(<span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">new</span> <span class="built_in">Date</span>(d.key).getUTCFullYear() === year;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新标题数据</span></span><br><span class="line">    d3.select(<span class="string">'h2'</span>)</span><br><span class="line">        .text(<span class="string">'World Cup '</span> + year);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择页面上所有的circle</span></span><br><span class="line">    <span class="keyword">var</span> circles = svg.selectAll(<span class="string">'circle'</span>)</span><br><span class="line">                    .data(filter, key_func); <span class="comment">//做了update，执行完只有一个圆圈被选中</span></span><br><span class="line">    </span><br><span class="line">    circles.exit() <span class="comment">// 包含20个元素的数组（包括一个parentNode）；exit就是本页面未包含的内容</span></span><br><span class="line">            .remove(); <span class="comment">// 移除由exit查找出的不属于页面的元素进行移除</span></span><br><span class="line"></span><br><span class="line">    circles.enter() <span class="comment">// 对应包含1个元素的数组，含有'update'属性</span></span><br><span class="line">            .append(<span class="string">'circle'</span>)</span><br><span class="line">            .transition()</span><br><span class="line">            .duration(<span class="number">500</span>)</span><br><span class="line">            .attr(<span class="string">'cx'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> d.values.x;</span><br><span class="line">            &#125;)</span><br><span class="line">            .attr(<span class="string">'cy'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> d.values.y;</span><br><span class="line">            &#125;)</span><br><span class="line">            .attr(<span class="string">'r'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> radius(d.values[<span class="string">'attendance'</span>]);</span><br><span class="line">            &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 突出当前年参加的国家</span></span><br><span class="line">    <span class="keyword">var</span> countries = filter[<span class="number">0</span>].values[<span class="string">'teams'</span>];</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">update_countries</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(countries.indexOf(d.properties.name) !== <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'lightBlue'</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'white'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    svg.selectAll(<span class="string">'path'</span>)</span><br><span class="line">        .transition()  <span class="comment">// 使用过渡来平滑化动画</span></span><br><span class="line">        .duration(<span class="number">500</span>)</span><br><span class="line">        .style(<span class="string">'fill'</span>, update_countries);</span><br><span class="line">        <span class="comment">//.style('stroke', update_countries)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h4 id="data-enter和exit"><a href="#data-enter和exit" class="headerlink" title="data, enter和exit"></a>data, enter和exit</h4><p><code>selection.data([values[, key]])</code><br>连接指定的一组数据的和当前选择。指定的values是一组数据值（例如，数字或对象）或一个函数返回一组值。如果没有指定key函数，则values的第一数据被分配到当前选择中第一元素，第二数据分配给当前选择的第二个元素，依此类推。当数据被分配给一个元素，它被存储在属性<code>__data__</code>中，从而使数据“沾粘”，从而使数据可以再选择。<br><code>data</code>操作的结果是<code>update</code>选择;这表示选择的DOM元素已成功绑定到指定的数据元素。<code>update</code>选择还包含对<code>enter</code>和<code>exit</code>的选择，对应于添加和删除数据节点。<br><code>key</code>函数可以被指定为控制数据是如何连接元素。<code>key</code>函数，基于先前结合的数据返回一个用于连接数据和相关的元素的字符串。例如，如果每个数据都有一个唯一的字段<code>name</code>，该连接可以被指定为<code>.data(data, function(d) { return d.name; })</code></p><p><code>selection.enter()</code><br>返回输入（enter）选择：<strong>当前选择中存在但是当前DOM元素中还不存在的每个数据元素的占位符节点</strong>。此方法只在由<code>data</code>运算符返回的更新选择中定义。此外，输入选择只定义了<code>append</code>，<code>insert</code>，<code>select</code>和<code>call</code>操作符；必须使用这些操作符在修改任何内容之前实例化输入元素。</p><p><code>selection.exit()</code><br>返回退出（exit）选择：<strong>找出在当前选择存在的DOM元素中没有新的数据元素</strong>。此方法只被定义在<code>data</code>运算符返回的更新选择。<code>exit</code>选择定义了所有的正常操作符，但通常你主要使用的是<code>remove</code>；其他操作符存在的主要目的是让您可以根据需要定义一个退出的过渡。</p><h4 id="添加动画"><a href="#添加动画" class="headerlink" title="添加动画"></a>添加动画</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> years = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1930</span>; i &lt; <span class="number">2015</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(i !== <span class="number">1942</span> &amp;&amp; i != <span class="number">1946</span>) <span class="comment">// 这两年因为二战没有举办世界杯</span></span><br><span class="line"> years.push(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> year_idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> year_interval = setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    update(years[year_idx]);</span><br><span class="line"></span><br><span class="line">    year_idx ++;</span><br><span class="line">    <span class="keyword">if</span>(year_idx &gt;= years.length)&#123; <span class="comment">// 停止条件</span></span><br><span class="line">        clearInterval(year_interval);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p><img src="/images/blogs/dv&amp;d3/lesson8/worldcup3.gif" alt></p><h3 id="reader-driven-narrative-interactive"><a href="#reader-driven-narrative-interactive" class="headerlink" title="reader driven narrative (interactive)"></a>reader driven narrative (interactive)</h3><p>在动画结束之后，提供按钮以供读者自行点选年份进行比较。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> year_interval = setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    update(years[year_idx]);</span><br><span class="line"></span><br><span class="line">    year_idx ++;</span><br><span class="line">    <span class="keyword">if</span>(year_idx &gt;= years.length)&#123;</span><br><span class="line">        clearInterval(year_interval);</span><br><span class="line">        <span class="keyword">var</span> buttons = d3.select(<span class="string">'body'</span>)</span><br><span class="line">            .append(<span class="string">'div'</span>)</span><br><span class="line">            .attr(<span class="string">'class'</span>, <span class="string">'years_buttons'</span>)</span><br><span class="line">            .selectAll(<span class="string">'div'</span>)</span><br><span class="line">            .data(years)</span><br><span class="line">            .enter()</span><br><span class="line">            .append(<span class="string">'div'</span>)</span><br><span class="line">            .text(<span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> d;</span><br><span class="line">            &#125;);</span><br><span class="line">        buttons.on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 先将目前的特殊样式进行清理</span></span><br><span class="line">            d3.select(<span class="string">'.years_buttons'</span>)</span><br><span class="line">                .selectAll(<span class="string">'div'</span>)</span><br><span class="line">                .transition()</span><br><span class="line">                .duration(<span class="number">500</span>)</span><br><span class="line">                .style(<span class="string">'background'</span>, <span class="string">'rgb(251, 201, 127)'</span>)</span><br><span class="line">                .style(<span class="string">'color'</span>, <span class="string">'black'</span>);</span><br><span class="line"></span><br><span class="line">            d3.select(<span class="keyword">this</span>)</span><br><span class="line">                .transition()</span><br><span class="line">                .duration(<span class="number">500</span>)</span><br><span class="line">                .style(<span class="string">'background'</span>, <span class="string">'lightBlue'</span>)</span><br><span class="line">                .style(<span class="string">'color'</span>, <span class="string">'white'</span>);</span><br><span class="line">            update(d);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure></p><p><img src="/images/blogs/dv&amp;d3/lesson8/worldcup4.gif" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一节(Lesson 8)实现动画效果。&lt;br&gt;
    
    </summary>
    
    
      <category term="Data Visualization and D3.js" scheme="https://soundquiet.github.io/categories/Data-Visualization-and-D3-js/"/>
    
    
      <category term="data visualization" scheme="https://soundquiet.github.io/tags/data-visualization/"/>
    
      <category term="d3.js" scheme="https://soundquiet.github.io/tags/d3-js/"/>
    
  </entry>
  
  <entry>
    <title>Fluent Python 读书笔记(4)</title>
    <link href="https://soundquiet.github.io/2018/11/02/Fluent-Python-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-4/"/>
    <id>https://soundquiet.github.io/2018/11/02/Fluent-Python-读书笔记-4/</id>
    <published>2018-11-02T13:03:47.000Z</published>
    <updated>2018-11-02T13:08:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>包括对象(第8、9章)、序列(第10章)、接口（第11章）、继承（第12章）、重载运算符（第13章）和生成器（第14章）<br><a id="more"></a></p><h1 id="Chap-8-对象引用、可变性和垃圾回收"><a href="#Chap-8-对象引用、可变性和垃圾回收" class="headerlink" title="Chap 8 对象引用、可变性和垃圾回收"></a>Chap 8 对象引用、可变性和垃圾回收</h1><h2 id="8-1-变量不是盒子"><a href="#8-1-变量不是盒子" class="headerlink" title="8.1 变量不是盒子"></a>8.1 变量不是盒子</h2><p>对于引用式变量来说，说<strong>把变量分配给对象</strong>更合理，毕竟，对象在赋值前就创建了。</p><p>为了理解Python中赋值语句，应该始终先读右边。对象在右边创建或获取，之后左边的变量才会绑定到对象上。</p><h2 id="8-2-标识、相等性和别名"><a href="#8-2-标识、相等性和别名" class="headerlink" title="8.2 标识、相等性和别名"></a>8.2 标识、相等性和别名</h2><p>变量不过是标注，所以对象可以被贴上多个标注，这些多个标注就是<strong>别名</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="string">'name'</span>: <span class="string">'Charles'</span>&#125;</span><br><span class="line">b = a </span><br><span class="line">b <span class="keyword">is</span> a <span class="comment"># true, they have same id</span></span><br><span class="line">c = &#123;<span class="string">'name'</span>: <span class="string">'Charles'</span>&#125;</span><br><span class="line">c == a <span class="comment"># true</span></span><br><span class="line">c <span class="keyword">is</span> a <span class="comment"># false</span></span><br></pre></td></tr></table></figure><p><code>==</code>比较值，而<code>is</code>比较标识。通常我们关注值，所以<code>==</code>的使用比较多。但是在变量和单例值之间比较时，应该使用<code>is</code>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line">x <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure></p><p><code>is</code>速度比较快，因为不能重载。而<code>a==b</code>等同于<code>a.__eq__(b)</code>.</p><blockquote><p>每个变量都有标识、类型和值。对象一旦创建，它的标识就不会变；可以把标识看作对象在内存中的地址。 <code>is</code>运算符比较两个对象的标识；<code>id()</code>函数返回对对象标识的整数表示。</p></blockquote><h3 id="元组的相对不可变性"><a href="#元组的相对不可变性" class="headerlink" title="元组的相对不可变性"></a>元组的相对不可变性</h3><p>元组保存的是对象的引用，如果引用的元素可变，即使元组本身不可变，元素依然可变。</p><blockquote><p>元组的不可变性其实是指tuple数据结构的物理内容（即保存的引用）不可变，与引用的对象无关。</p></blockquote><p><img src="/images/blogs/FluentPython/tuple.gif" alt></p><h2 id="8-3-默认做浅复制"><a href="#8-3-默认做浅复制" class="headerlink" title="8.3 默认做浅复制"></a>8.3 默认做浅复制</h2><p>复制列表（或多数内置的可变集合）最简单的方法是使用内置的类型构造方法：<br><code>l2 = list(l1)</code><br>或者使用简洁的<code>l2 = l1[:]</code>语句。</p><p>上述两种方法做的都是<strong>浅复制</strong>，即复制了最外层容器，副本中的元素是源容器中元素的引用。</p><p><img src="/images/blogs/FluentPython/copy.gif" alt></p><p>对于元组来说，<code>+=</code>创建一个新元组，重新绑定给变量。而对于列表来说，<code>+=</code>是个就地操作，对象不变。</p><h3 id="深复制-amp-amp-浅复制"><a href="#深复制-amp-amp-浅复制" class="headerlink" title="深复制 &amp;&amp; 浅复制"></a>深复制 &amp;&amp; 浅复制</h3><p><code>copy</code>模块提供的<code>deepcopy</code>和<code>copy</code>能为任意对象做深复制和浅复制。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">a = &#123;<span class="string">'name'</span>: <span class="string">'english'</span>&#125;</span><br><span class="line">b = copy.copy(a) <span class="comment"># 浅复制</span></span><br><span class="line">c = copy.deepcopy(a) <span class="comment"># 深复制</span></span><br></pre></td></tr></table></figure></p><h2 id="8-4-函数的参数作为引用时"><a href="#8-4-函数的参数作为引用时" class="headerlink" title="8.4 函数的参数作为引用时"></a>8.4 函数的参数作为引用时</h2><p>Python唯一支持的参数传递模式是<strong>共享传参</strong>（call by sharing)，指函数的各个形式参数获得实参中的各个引用的副本，也就是说，函数内部的形参是实参的别名。</p><p>所以函数可能会修改作为参数传入的可变对象。 –&gt; 避免使用可变对象做参数默认值。</p><p><strong>通常使用None作为接受可变对象的参数的默认值</strong>，在类中直接把参数赋值给变量时要注意，是真的需要修改参数，还是可以通过<strong>创建副本</strong>来避免麻烦。</p><h2 id="8-5-del和垃圾回收"><a href="#8-5-del和垃圾回收" class="headerlink" title="8.5 del和垃圾回收"></a>8.5 del和垃圾回收</h2><blockquote><p>对象绝不会自行销毁；然而，无法得到对象时，可能会被当作垃圾回收。</p></blockquote><p><code>del</code>语句删除名称，而不是对象。<code>del</code>命令可能会导致对象被当作垃圾回收，但是仅当删除的变量保存的是对象的最后一个引用，或者无法得到对象时。重新绑定也可能会导致对象的引用数量归零，导致对象被销毁。</p><p>CPython中使用引用计数来决定是否垃圾回收。当引用计数归零，对象就被销毁。</p><h2 id="8-6-弱引用"><a href="#8-6-弱引用" class="headerlink" title="8.6 弱引用"></a>8.6 弱引用</h2><p>弱引用不会增加对象的引用数量，即不会妨碍所指对象（引用的对象目标）被当作垃圾回收。</p><p>弱引用在缓存应用中很有用，可以不用因为被缓存引用而始终保存缓存对象。</p><p><code>weakfer</code>模块中的<code>ref</code>（底层接口，供高级用途）、<code>WeakValueDictionary</code>、<code>WeakKeyDictionary</code>、<code>WeakSet</code>是常用集合</p><h2 id="8-7-Python对不可变类型施加的把戏"><a href="#8-7-Python对不可变类型施加的把戏" class="headerlink" title="8.7 Python对不可变类型施加的把戏"></a>8.7 Python对不可变类型施加的把戏</h2><p>对元组<code>t</code>来说，<code>t[:]</code>不创建副本，而是返回同一个对象的引用，<code>tuple(t)</code>也是如此。<br><code>str</code>,<code>bytes</code>和<code>frozenset</code>实例也有这种行为。<code>frozenset</code>实例不是序列，不能使用<code>[:]</code>，但是<code>frozenset.copy()</code>具有同样的效果。</p><p>共享字符串字面量称为<strong>驻留</strong>，Cpython还会在小的整数上使用这个策略，防止重复创建，如0、-1、42. 所以比较字符串和整数是否相等时应使用<code>==</code>。</p><h2 id="8-8-小结"><a href="#8-8-小结" class="headerlink" title="8.8 小结"></a>8.8 小结</h2><ul><li>简单的赋值不创建副本</li><li><code>+=</code>和<code>*=</code>的具体含义视左边的变量而变，如果不可变对象会创建新对象</li><li>对现有的变量赋新值，不会修改之前绑定的变量，这叫做重新绑定。如果变量是之前对象的最后一个引用，对象会被回收</li><li>函数的参数以别名的形式传递。所以函数可能会修改传入的可变对象。</li><li>使用可变对象作为函数的参数默认值有危险，如果就地修改了参数，默认值就改变了，会影响以后默认值的使用。</li></ul><h1 id="Chap-9-符合Python风格的对象"><a href="#Chap-9-符合Python风格的对象" class="headerlink" title="Chap 9 符合Python风格的对象"></a>Chap 9 符合Python风格的对象</h1><h2 id="9-1-对象表示形式"><a href="#9-1-对象表示形式" class="headerlink" title="9.1 对象表示形式"></a>9.1 对象表示形式</h2><ul><li>repr() –&gt; __repr__<br>以便于开发者理解的方式返回对象的字符串表示形式</li><li>str()  –&gt; __str__<br>以便于用户理解的方式返回对象的字符串表示形式</li></ul><p>此外还有两个特殊方法：</p><ul><li>__bytes__: bytes()函数调用它获取对象的字节序列表示形式</li><li>__format__： 被内置的format()函数和str.format()方法调用，使用特殊的格式代码显示对象的字符串表示形式</li></ul><h2 id="9-4-classmethod-与-staticmethod"><a href="#9-4-classmethod-与-staticmethod" class="headerlink" title="9.4 classmethod 与 staticmethod"></a>9.4 classmethod 与 staticmethod</h2><p><strong>classmethod</strong>定义操作类，而不是操作实例方法。类方法的第一个参数是类本身，而不是实例。按照约定，类方法的第一个参数名为<code>cls</code>。</p><blockquote><p><code>self</code>表示一个具体的实例本身<br>  <code>cls</code>表示类本身</p></blockquote><p><strong>staticmethod</strong>和<code>classmethod</code>非常的相似，但是不强制要求传递参数。它的本质是普通函数，但它不关注对象和对象内部属性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://stackoverflow.com/questions/12179271/meaning-of-classmethod-and-staticmethod-for-beginner </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, day=<span class="number">0</span>, month=<span class="number">0</span>, year=<span class="number">0</span>)</span>:</span></span><br><span class="line">        self.day = day</span><br><span class="line">        self.month = month</span><br><span class="line">        self.year = year</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_string</span><span class="params">(cls, date_as_string)</span>:</span></span><br><span class="line">        day, month, year = map(int, date_as_string.split(<span class="string">'-'</span>))</span><br><span class="line">        date1 = cls(day, month, year)</span><br><span class="line">        <span class="keyword">return</span> date1</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_date_valid</span><span class="params">(date_as_string)</span>:</span></span><br><span class="line">        day, month, year = map(int, date_as_string.split(<span class="string">'-'</span>))</span><br><span class="line">        <span class="keyword">return</span> day &lt;= <span class="number">31</span> <span class="keyword">and</span> month &lt;= <span class="number">12</span> <span class="keyword">and</span> year &lt;= <span class="number">3999</span></span><br><span class="line"></span><br><span class="line">date2 = Date.from_string(<span class="string">'11-09-2012'</span>)</span><br><span class="line">is_date = Date.is_date_valid(<span class="string">'11-09-2012'</span>)</span><br></pre></td></tr></table></figure><h2 id="9-5-格式化显示"><a href="#9-5-格式化显示" class="headerlink" title="9.5 格式化显示"></a>9.5 格式化显示</h2><p>内置的<code>format()</code>函数和<code>str.format()</code>方法把哥哥类型的格式化方式委托给相应的<code>.__format__(format_spec)</code>方法。<code>format_spec</code>是格式说明符，用于：</p><ul><li><code>format(my_obj, format_spec)</code>的第二个参数</li><li><code>str.format()</code>方法的格式字符串，<code>{}</code>里代换字段中冒号后面的部分。  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brl = <span class="number">1</span>/<span class="number">2.43</span></span><br><span class="line"><span class="string">'1 BRL = &#123;rate:0.2f&#125; USD'</span>.format(rate=brl)</span><br></pre></td></tr></table></figure></li></ul><p>冒号左边在代换字段句法中是字段名，后面是格式说明符。<br>格式规范微语言是可扩展的。<br>如果类没有定义<code>__format__</code>方法，从object继承的方法会返回<code>str(my_object)</code>。</p><h2 id="9-6-可散列化"><a href="#9-6-可散列化" class="headerlink" title="9.6 可散列化"></a>9.6 可散列化</h2><p>使用两个前导下划线（尾部没有或只有一个下划线）把属性标记为私有的。</p><p>想要创建可散列的类型，不一定要实现特性和保护实例属性，只需正确的实现<code>__hash__</code>和<code>__eq__</code>即可。但是实例的散列值绝不应该改变。</p><h2 id="9-7-Python的私有属性和“受保护的”属性"><a href="#9-7-Python的私有属性和“受保护的”属性" class="headerlink" title="9.7 Python的私有属性和“受保护的”属性"></a>9.7 Python的私有属性和“受保护的”属性</h2><p>通过<code>__variable</code>的形式（尾部最多有一个下划线）命名属性，Python会把属性名存入实例的<code>__dict__</code>属性中，而且会在前面加上一个下划线和类名，如<code>_myClass__variable</code>。这个特性叫<strong>名称改写（name mangling）</strong>。 这是一种安全措施，它的目的是避免意外访问，不能防止故意修改。<br><code>inst1._myClass__variable = 7</code>这种语句能修改实例的私有属性。  </p><p>也有程序员们不喜欢这种写法，他们约定使用一个下划线前缀编写受保护的属性，如<code>self._x</code>。<br>Python解释器不会对单个下划线的属性名做特殊处理，但是程序员们约定不会在类外部访问这种属性。<br>不过如果是模块的话，顶层名称使用一个下划线会有影响：<code>from mymod import *</code>不会用如前缀为下划线的名称，不过可以通过<code>from mymod import _mymod</code>的方式导入。</p><h2 id="9-8-使用-slots-类属性节省空间"><a href="#9-8-使用-slots-类属性节省空间" class="headerlink" title="9.8 使用__slots__类属性节省空间"></a>9.8 使用<code>__slots__</code>类属性节省空间</h2><p>Python在默认情况下将实例属性存储在各个实例中名为<code>__dict__</code>的字典里。<br>字典会消耗大量内存。<br>通过<code>__slots__</code>类属性，节省大量内存。  </p><p>定义<code>__slots__</code>的方法是：创建一个类属性，使用<code>__slots__</code>这个名字，并把它的值设为一个字符串构成的可迭代对象，其中的元素便是各个实例属性。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myClass</span>:</span></span><br><span class="line">    __slots__ = (<span class="string">'__x'</span>, <span class="string">'__y'</span>)</span><br><span class="line">    <span class="comment"># more codes ...</span></span><br></pre></td></tr></table></figure></p><p><code>__slots__</code>属性告诉解释器：这个类中的所有实例属性都在这儿。 这样解释器就会在各个实例中使用类似元组的结构存储实例变量，避免使用<code>__dict__</code>属性。  </p><p>在类中定义了<code>__slots__</code>之后，实例中不能有没出现在<code>__slots__</code>中的其他属性。<br>如果在<code>__slots__</code>中添加<code>__dict__</code>，实例会在元组中保存各个实例的属性，还支持动态添加属性，存储在<code>__dict__</code>中。</p><p>用户定义的类中默认就有<code>__weakref__</code>属性，如果在类中定义<code>__slots__</code>属性，则要手动添加<code>__weakref__</code>，来让对象支持弱引用。</p><p>实例特别多时才推荐使用。</p><p><strong>每个子类都要定义<code>__slots__</code>属性，因为继承器会忽略继承的<code>__slots__</code>属性</strong>。</p><h2 id="9-9-覆盖类属性"><a href="#9-9-覆盖类属性" class="headerlink" title="9.9 覆盖类属性"></a>9.9 覆盖类属性</h2><p>Python有个独特的特性：类属性可用于为实例属性提供默认值。</p><p>如果为不存在的实例属性赋值，会新建实例属性。</p><p>类属性是公开的，会被子类继承，因此可以创建一个子类，只用于定制类的数据属性，这样更具Python风格。</p><h1 id="Chap-10-序列的修改、散列和切片"><a href="#Chap-10-序列的修改、散列和切片" class="headerlink" title="Chap 10 序列的修改、散列和切片"></a>Chap 10 序列的修改、散列和切片</h1><h2 id="10-3-协议和鸭子类型"><a href="#10-3-协议和鸭子类型" class="headerlink" title="10.3 协议和鸭子类型"></a>10.3 协议和鸭子类型</h2><p>在Python中创建功能完善的序列类型无需使用继承，只需实现符合序列协议的方法。<br>在面向对象编程中，协议是非正式的接口，只在文档中定义，在代码中不定义。例如，Python中的序列协议只需要<code>__len__</code>和<code>__getitem__</code>两个方法。任何类只要使用标准的签名和语义实现了这两个方法，就能用在任何期待序列的地方。</p><p>协议是非正式的，没有强制力，因此如果你知道类的具体使用场景，通常只需要实现一个协议的部分。</p><h2 id="10-4-切片"><a href="#10-4-切片" class="headerlink" title="10.4 切片"></a>10.4 切片</h2><p>slice中有个<code>indices</code>属性，<code>help(slice.indices)</code>给出的信息：</p><blockquote><p>S.indices(len) -&gt; (start, stop, stride)<br>给定长度为len的序列，计算S表示的扩展切片的起始和结尾索引，以及步幅。超过边界的索引会被截掉。</p></blockquote><p>indices将start，end和stride都变成非负数。，而且都落在指定长度序列的边界内。</p><h2 id="10-5-动态存取属性"><a href="#10-5-动态存取属性" class="headerlink" title="10.5 动态存取属性"></a>10.5 动态存取属性</h2><p>属性查找失败后，解释器调用<code>__getattr__</code>方法，简单来说，对于<code>my_obj.x</code>表达式，Python会检查<code>my_obj</code>实例有没有名为<code>x</code>的属性；如果没有，到类<code>(my_obj.__class__)</code>中查找；如果还没有，顺着继承树继续查找；如果依旧找不到，就调用<code>my_obj</code>所属类中定义的<code>__getattr__</code>方法，传入<code>self</code>和属性名称的字符串形式。</p><h2 id="10-6-散列和快速等值测试"><a href="#10-6-散列和快速等值测试" class="headerlink" title="10.6 散列和快速等值测试"></a>10.6 散列和快速等值测试</h2><h3 id="实现hash方法"><a href="#实现hash方法" class="headerlink" title="实现hash方法"></a>实现<strong>hash</strong>方法</h3><p><code>functools.reduce()</code>可以替换为<code>sum()</code>，关键思想是：把一系列值归约成单个值。</p><blockquote><p>归约函数(reduce, map, any, all)把序列或有限的可迭代对象变成一个聚合结果</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools, operator</span><br><span class="line"><span class="comment"># 计算0-5的累计异或</span></span><br><span class="line">functools.reduce(operator.xor, range(<span class="number">6</span>))</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line">    <span class="comment"># codes</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__hash__</span><span class="params">(self)</span>:</span></span><br><span class="line">        hashes = (hash(x) <span class="keyword">for</span> x <span class="keyword">in</span> self._components)</span><br><span class="line">        <span class="keyword">return</span> functools.reduce(operator.xor, hashes, <span class="number">0</span>) <span class="comment"># 0是初始值</span></span><br></pre></td></tr></table></figure><p><code>reduce</code>函数有个参数，<code>reduce(function, iterable, initializer)</code>，如果序列为空，<code>initializer</code>是返回的结果，否则在归约中使用它作为第一个参数，因此应该使用恒等值。对于<code>+, |, ^</code>来说，应该是0， 对于<code>*, &amp;</code>是1。</p><blockquote><p><strong>映射归约</strong>：把函数应用到各个元素上，生成一个新的序列（映射，map），然后计算聚合值（归约，reduce）</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__hash__</span><span class="params">(self)</span>:</span></span><br><span class="line">    hashes = map(hash, self._components)</span><br><span class="line">    <span class="keyword">return</span> functools.reduce(operator.xor, hashes)</span><br></pre></td></tr></table></figure><h3 id="实现eq方法"><a href="#实现eq方法" class="headerlink" title="实现eq方法"></a>实现<strong>eq</strong>方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> tuple(self) == tuple(other)</span><br></pre></td></tr></table></figure><p>这个方法复制两个操作数，构建两个元组进行比较，使用tuple类型的<code>__eq__</code>方法。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(self) != len(other):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> a, b <span class="keyword">in</span> zip(self, other):</span><br><span class="line">        <span class="keyword">if</span> a != b:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure></p><p><code>zip</code>函数生成一个由元组构成的生成器。必须先比较长度，因为<code>zip</code>一旦有一个输入耗尽，就会立即停止生成值，而且不会抛出异常。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> len(self) == len(other) <span class="keyword">and</span> all(a == b <span class="keyword">for</span> a,b <span class="keyword">in</span> zip(self, other))</span><br></pre></td></tr></table></figure></p><h1 id="Chap-11-接口-从协议到抽象基类"><a href="#Chap-11-接口-从协议到抽象基类" class="headerlink" title="Chap 11 接口: 从协议到抽象基类"></a>Chap 11 接口: 从协议到抽象基类</h1><p>本章讨论从鸭子类型的代表特征动态协议到使接口更明确、能验证实现是否符合规定的抽象基类。</p><h2 id="11-1-Python文化中的接口和协议"><a href="#11-1-Python文化中的接口和协议" class="headerlink" title="11.1 Python文化中的接口和协议"></a>11.1 Python文化中的接口和协议</h2><p>Python语言中没有interface关键字，而且除了抽象基类，每个类都有接口：类实现或继承的公开属性（方法或数据属性），包括特殊方法，如<code>__getitem__</code>.<br>按照<strong>定义</strong>，受保护的属性和私有属性不在接口中：即便只是采用命名约定实现“保护”；私有属性可以轻松地访问。</p><p>关于接口，有个实用的补充定义：对象公开方法的子集，让对象在系统中扮演特定的角色。</p><p>接口是实现特定角色的方法集合。  </p><p>协议和继承没有关系。</p><p>一个类会实现多个接口，从而让实例扮演多个角色。</p><p>协议是接口，但不是正式的，只由文档和约定定义。  </p><p>一个类可能只实现部分接口。</p><h2 id="11-2-Python喜欢序列"><a href="#11-2-Python喜欢序列" class="headerlink" title="11.2 Python喜欢序列"></a>11.2 Python喜欢序列</h2><p>序列协议是Python最基础的协议之一，即使对象只实现了那个协议最基本的一部分，解释器也会负责地处理。</p><p>Python会特殊对待<em>看起来</em>像是序列的对象。</p><h2 id="11-3-猴子补丁"><a href="#11-3-猴子补丁" class="headerlink" title="11.3 猴子补丁"></a>11.3 猴子补丁</h2><p>猴子补丁：在运行时修改类或模块，而不改动源码。打补丁的代码要和打补丁的程序耦合紧密，所以需要处理隐藏和没有文档的部分。</p><h2 id="11-4-抽象基类"><a href="#11-4-抽象基类" class="headerlink" title="11.4 抽象基类"></a>11.4 抽象基类</h2><p>By Alex Martelli<br>鸭子类型是指忽略对象的真正类型，转而关注对象有没有实现所需的方法、签名和语义。对Python来说，这基本上避免使用<code>isinstance</code>检查对象的类型。  </p><p>白鹅类型是指，只要cls是抽象基类，即cls的元类是<code>abc.ABCMeta</code>，就可以使用<code>isinstance(obj, cls)</code>。  </p><p>抽象基类可以在代码中使用<code>register</code>类方法把某个类“声明”为一个抽象基类的“虚拟”子类，被注册的类要求满足抽象基类对方法名称和签名的要求，最重要的是满足底层语义契约。<br>有时甚至不需要注册，抽象基类也能识别子类。</p><h2 id="11-5-抽象子类的子类"><a href="#11-5-抽象子类的子类" class="headerlink" title="11.5 抽象子类的子类"></a>11.5 抽象子类的子类</h2><p>导入时，Python不会检查子类中抽象方法的实现，在运行时实例化子类才会真正检查。</p><p>在<code>collections.abc</code>中，每个抽象基类的具体方法都是作为类的公开接口实现的，因此不用知道实例的内部结构。</p><h2 id="11-7-抽象基类定义与使用"><a href="#11-7-抽象基类定义与使用" class="headerlink" title="11.7 抽象基类定义与使用"></a>11.7 抽象基类定义与使用</h2><h3 id="虚拟子类"><a href="#虚拟子类" class="headerlink" title="虚拟子类"></a>虚拟子类</h3><p>注册虚拟子类的方法是在抽象基类上调用<code>register</code>方法，注册的类会变成抽象基类的虚拟子类，而且<code>issubclass</code>和<code>isinstance</code>等函数都能识别。<strong>但是注册的类不会从抽象基类中继承任何方法和属性</strong>（不会被检查）。<br>为了避免运行时错误，虚拟子类要实现所需的全部方法。<br>注册虚拟子类可以使用类装饰器，单更常用的是把它当作函数使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tombola <span class="keyword">import</span> Tombola</span><br><span class="line"></span><br><span class="line"><span class="meta">@Tombola.register</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TomboList</span><span class="params">(list)</span>:</span></span><br><span class="line">    <span class="comment"># codes...</span></span><br><span class="line"></span><br><span class="line">Sequence.register(str)</span><br></pre></td></tr></table></figure><p>类的继承关系在一个特殊的类属性中指定——<code>__mro__</code>，它会列出“真实”的超类，不会显示虚拟注册的基类。</p><h2 id="11-11-小结"><a href="#11-11-小结" class="headerlink" title="11.11 小结"></a>11.11 小结</h2><p><strong>不要自己定义抽象基类</strong></p><p><strong>不要过度使用抽象基类</strong></p><h1 id="Chap-12-继承的优缺点"><a href="#Chap-12-继承的优缺点" class="headerlink" title="Chap 12 继承的优缺点"></a>Chap 12 继承的优缺点</h1><h2 id="12-1-子类化内置类型"><a href="#12-1-子类化内置类型" class="headerlink" title="12.1 子类化内置类型"></a>12.1 子类化内置类型</h2><p>内置类型（使用C语言编写）不会调用用户定义的类覆盖的特殊方法。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoppelDict</span><span class="params">(dict)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        super().__setitem__(key, [value] * <span class="number">2</span>)</span><br><span class="line">dd = DoppelDict(one=<span class="number">1</span>)</span><br><span class="line">dd[<span class="string">'two'</span>] = <span class="number">2</span> <span class="comment"># dd为&#123;'one':1, 'two':[2,2]&#125;</span></span><br><span class="line">dd.update(three=<span class="number">3</span>) <span class="comment"># dd为&#123;'three': 3,'one':1, 'two':[2,2]&#125;</span></span><br><span class="line"><span class="comment"># 不会使用我们覆盖的__setitem__方法</span></span><br></pre></td></tr></table></figure></p><p>这样违背了面向对象编程的一个基本原则: 始终从实例（self）所属的类开始搜索方法，即使在超类实现的类中调用也是如此。<br>直接子类化内置类型容易出错，用户自己定义的类应该继承<code>collections</code>模块中的类，比如<code>UserDict</code>, <code>UserList</code>和<code>UserString</code>。</p><h2 id="12-2-多重继承和方法解析顺序"><a href="#12-2-多重继承和方法解析顺序" class="headerlink" title="12.2 多重继承和方法解析顺序"></a>12.2 多重继承和方法解析顺序</h2><p>如果同级别的超类定义了同名属性，Python如何确定选择哪一个？这种冲突称为“菱形问题”。<br><img src="/images/blogs/FluentPython/diamond-uml.png" alt><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ping</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'ping:'</span>, self)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pong</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'pong:'</span>, self)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pong</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'PONG:'</span>, self)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(B, C)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ping</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().ping()</span><br><span class="line">        print(<span class="string">'post-ping:'</span>, self)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pingpong</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.ping()</span><br><span class="line">        super().ping()</span><br><span class="line">        self.pong()</span><br><span class="line">        super().pong()</span><br><span class="line">        C.pong(self)</span><br></pre></td></tr></table></figure></p><p>B和C都实现了<code>pong()</code>，区别是输出的大小写不同。<br><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span> d =D()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span> d.ping()</span><br><span class="line">ping: &lt;__main__.D object at 0x0000019678ED55C0&gt;</span><br><span class="line">post-ping: &lt;__main__.D object at 0x0000019678ED55C0&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span> d.pong()</span><br><span class="line">pong: &lt;__main__.D object at 0x0000019678ED55C0&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span> d.pingpong()</span><br><span class="line">ping: &lt;__main__.D object at 0x0000019678ED55C0&gt;</span><br><span class="line">post-ping: &lt;__main__.D object at 0x0000019678ED55C0&gt;</span><br><span class="line">ping: &lt;__main__.D object at 0x0000019678ED55C0&gt;</span><br><span class="line">pong: &lt;__main__.D object at 0x0000019678ED55C0&gt;</span><br><span class="line">pong: &lt;__main__.D object at 0x0000019678ED55C0&gt;</span><br><span class="line">PONG: &lt;__main__.D object at 0x0000019678ED55C0&gt;</span><br></pre></td></tr></table></figure></p><p>直接运行<code>d.pong()</code>运行的是类B中的代码。在类D中的<code>self.pong()</code>也是B中的代码。<br>这是因为Python会根据<strong>方法解析顺序</strong>来遍历继承图。<br><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span> D.__mro__</span><br><span class="line">(__main__.D, __main__.B, __main__.C, __main__.A, object)</span><br></pre></td></tr></table></figure></p><p>如果想把方法调用委托给超类，推荐使用内置的<code>super()</code>函数。或者直接在类上调用实例方法，此时必须显式传入<code>self</code>参数，因为这样访问的是<em>未绑定方法</em>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(B, C)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ping</span><span class="params">(self)</span>:</span></span><br><span class="line">        A.ping(self)</span><br></pre></td></tr></table></figure></p><p>使用<code>super()</code>调用方法时，会遵守方法解析顺序。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pingpong</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.ping() <span class="comment"># 运行D类的ping</span></span><br><span class="line">    super().ping() <span class="comment"># 跳过D类的ping，找到A类的ping</span></span><br><span class="line">    self.pong() <span class="comment"># 根据__mro__，找到B类实现的pong方法</span></span><br><span class="line">    super().pong() <span class="comment"># 同上</span></span><br><span class="line">    C.pong(self) <span class="comment"># 忽略__mro__, 找到C类的pong</span></span><br></pre></td></tr></table></figure></p><p>方法解析顺序不仅考虑继承图，还考虑子类声明中列出超类的顺序。如果D的声明为<code>(C, B)</code>，那么D类的<code>__mro__</code>属性就会先是C。</p><h2 id="12-4-处理多重继承"><a href="#12-4-处理多重继承" class="headerlink" title="12.4 处理多重继承"></a>12.4 处理多重继承</h2><ol><li><strong>把接口继承和实现继承区分开</strong><ul><li>继承接口，创建子类型，实现“是什么”的关系</li><li>继承实现，通过重用避免代码重复</li></ul></li><li><strong>使用抽象基类显式表示接口</strong></li><li><strong>通过混入重用代码</strong><br>如果一个类的作用是为多个不相关的子类提供方法实现，从而实现重用，但不体现“是什么”关系，这个类应明确定义为<strong>混入类(mixin class)</strong>。从概念上讲，混入不定义新类型，只是打包方法，便于重用。混入类绝对不能实例化，而且具体类不能<strong>只</strong>继承混入类。</li><li><strong>在名称中明确指明混入</strong><br>在名称中加入<code>...MiXin</code></li><li><strong>抽象基类可以作为混入，反之不成立</strong></li><li><strong>不要子类化多个具体类</strong><br>具体类可以没有，或最多只有一个具体超类。</li><li><strong>为用户提供聚合类</strong><br>如果抽象基类或混入的组合对客户代码非常有用，那就提供一个类，使用便于理解的方式把他们结合起来。</li><li><strong>优先使用对象组合，而不是类继承</strong>  </li></ol><h1 id="Chap-13-正确重载运算符"><a href="#Chap-13-正确重载运算符" class="headerlink" title="Chap 13 正确重载运算符"></a>Chap 13 正确重载运算符</h1><p>运算符重载的作用是让用户定义的对象使用中缀运算符或一元运算符。</p><h2 id="13-1-运算符重载基础"><a href="#13-1-运算符重载基础" class="headerlink" title="13.1 运算符重载基础"></a>13.1 运算符重载基础</h2><ul><li>不能重载内置类型的运算符</li><li>不能新建运算符，只能重载现有的</li><li>某些运算符不能重载 —— is, and, or, not（但是位运算符&amp;、|、~可以）</li></ul><h2 id="13-2-一元运算符"><a href="#13-2-一元运算符" class="headerlink" title="13.2 一元运算符"></a>13.2 一元运算符</h2><ul><li>- (__neg__)  一元取负算数运算符</li><li><ul><li>(__pos__) 一元取正算数运算符，通常<code>x == +x</code>。The unary + (plus) operator yields its numeric argument unchanged.</li></ul></li><li>~ (__invert__) 对整数按位取反，定义为<code>~x == -(x+1)</code></li></ul><p>这些特殊方法只有一个参数<code>self</code>。<br>遵守运算符的一个规则：始终返回一个新对象，也就是不能修改<code>self</code>，要创建并返回合适类型的新实例。<br>多数时候，<code>+</code>最好返回<code>self</code>的副本。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__abs__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> math.sqrt(sum(x * x <span class="keyword">for</span> x <span class="keyword">in</span> self))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__neg__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> Vector(-x <span class="keyword">for</span> x <span class="keyword">in</span> self)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__pos__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> Vector(self)</span><br></pre></td></tr></table></figure></p><h2 id="13-3-重载加法运算符"><a href="#13-3-重载加法运算符" class="headerlink" title="13.3 重载加法运算符+"></a>13.3 重载加法运算符+</h2><p><img src="/images/blogs/FluentPython/flowchart-operator.png" alt><br><code>__radd__</code>是<code>__add__</code>的反向版本，在右操作数上调用。</p><p><code>NotImplemented</code>是特殊单例值，而<code>NotImplementedError</code>是一种异常，抽象类中的占位方法把它抛出，提醒子类必须覆盖。</p><p>如果由于类型不兼容而导致运算符特殊方法无法返回有效结果时，应返回<code>NotImplemented</code>，而不是<code>TypeError</code>，这样另一个操作数所属的类型还有机会执行运算，即反向运算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        pairs = itertools.zip_longest(self, other, fillvalue = <span class="number">0.0</span>)</span><br><span class="line">        <span class="keyword">return</span> Vector(a + b <span class="keyword">for</span> a, b <span class="keyword">in</span> pairs)</span><br><span class="line">    <span class="keyword">except</span> TypeError:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__radd__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self + other <span class="comment"># radd 直接委托 add</span></span><br></pre></td></tr></table></figure><h2 id="13-4-重载标量乘法运算符"><a href="#13-4-重载标量乘法运算符" class="headerlink" title="13.4 重载标量乘法运算符 *"></a>13.4 重载标量乘法运算符 *</h2><p>Python中的<code>*</code>为标量积，各个分量会乘以后面的数字，也叫元素级乘法。<br>对于乘法来说，需要考虑操作数类型不兼容的问题。在加法重载中，使用了鸭子类型，捕获<code>TypeError</code>。在这里，可以使用<strong>白鹅类型</strong>，使用<code>isinstance()</code>检查类型，但是不硬编码具体的类型，而检查<code>numbers.Real</code>抽象基类。这个抽象基类覆盖我们所需的类型，而且可以兼容后续被声明为该抽象基类的真实/虚拟子类的数值类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__mul__</span><span class="params">(self, scalar)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(scalar, numbers.Real):</span><br><span class="line">        <span class="keyword">return</span> Vector(n * scalar <span class="keyword">for</span> n <span class="keyword">in</span> self)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__rmul__</span><span class="params">(self, scalar)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self * scalar</span><br></pre></td></tr></table></figure><p><strong>点乘</strong>，在<code>Numpy</code>中使用<code>numpy.dot()</code>函数计算，Python3.5引入<code>@</code>中缀运算符来计算点积。</p><h2 id="13-5-众多比较运算符"><a href="#13-5-众多比较运算符" class="headerlink" title="13.5 众多比较运算符"></a>13.5 众多比较运算符</h2><ul><li>正向和反向调用使用同一系列方法。</li><li>对<code>==</code>和<code>!=</code>来说，如果反向调用失败，Python会比较对象的id，而不抛出TypeError</li></ul><p>Python3 之后对于<code>__ne__</code>，返回对<code>__eq__</code>结果的取反。</p><h2 id="13-6-增量赋值运算符"><a href="#13-6-增量赋值运算符" class="headerlink" title="13.6 增量赋值运算符"></a>13.6 增量赋值运算符</h2><p>如果一个类没有实现就地运算符，增量赋值运算只是语法糖：<code>a+=b</code>等同于<code>a=a+b</code>。如果定义了<code>__add__</code>，<code>+=</code>也能使用。<br>如果实现了就地运算符，就会就地修改左操作数，不会创建新的对象。但是对于不可变类型来说，这个运算符依然等同于语法糖。</p><p>与<code>+</code>相比，<code>+=</code>对第二个操作数更宽容。</p><h2 id="13-7-小结"><a href="#13-7-小结" class="headerlink" title="13.7 小结"></a>13.7 小结</h2><p>对于操作数类型来说，有两种处理方法：</p><ul><li>鸭子类型，直接执行运算，如果有问题再抛出TypeError异常</li><li>白鹅类型，通过显示检查抽象基类来得到类型结果</li></ul><h1 id="Chap-14-可迭代的对象、迭代器和生成器"><a href="#Chap-14-可迭代的对象、迭代器和生成器" class="headerlink" title="Chap 14 可迭代的对象、迭代器和生成器"></a>Chap 14 可迭代的对象、迭代器和生成器</h1><h2 id="14-1-序列可迭代的原因：iter函数"><a href="#14-1-序列可迭代的原因：iter函数" class="headerlink" title="14.1 序列可迭代的原因：iter函数"></a>14.1 序列可迭代的原因：iter函数</h2><p>解释器迭代对象x时，会调用<code>iter(x)</code>。内置的<code>iter</code>函数有以下作用：</p><ol><li>检查对象是否实现<code>__iter__</code>方法，如果实现了就调用，获取一个迭代器</li><li>如果没有实现<code>__iter__</code>，但是实现了<code>__getitem__</code>，Python会创建一个迭代器，尝试按顺序（从索引0开始）获取元素</li><li>如果尝试失败，Python抛出TypeError异常。</li></ol><!-- Python 3.4之后，检查对象是否可迭代，应该调用`iter(x)`，而不是`isinstance(x, abc.Iterable)`。因为前者会考虑到`__getitem__`. --><h2 id="14-2-可迭代对象与迭代器的对比"><a href="#14-2-可迭代对象与迭代器的对比" class="headerlink" title="14.2 可迭代对象与迭代器的对比"></a>14.2 可迭代对象与迭代器的对比</h2><blockquote><p><strong>可迭代的对象</strong><br>使用<code>iter</code>内置函数可以获取迭代器的对象。如果实现了能返回迭代器的<code>__iter__</code>方法，那么对象就是可迭代的。序列都可以迭代；实现了<code>__getitem__</code>方法，而且参数是从零开始的索引，这种对象也可以迭代。</p></blockquote><p><strong>Python从可迭代的对象中获取迭代器</strong>。</p><p>标准的迭代器接口有两个方法：</p><ul><li><code>__next__</code><br>返回下一个可用元素，如果没有，抛出<code>StopIteration</code></li><li><code>__iter__</code><br>返回<code>self</code>，以便在应该使用可迭代对象的地方使用迭代器。</li></ul><blockquote><p><strong>迭代器</strong><br>实现了无参数的<code>__next__</code>方法， 返回序列中的下一个元素；如果没有就抛出<code>StopIteration</code>。Python中迭代器还实现了<code>__iter__</code>方法，因此迭代器也可以迭代。</p></blockquote><h2 id="14-4-生成器函数"><a href="#14-4-生成器函数" class="headerlink" title="14.4 生成器函数"></a>14.4 生成器函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> self.words:</span><br><span class="line">        <span class="keyword">yield</span> word</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>只要函数的定义体内有<code>yield</code>关键字，这个函数就是生成器函数。调用生成器函数会返回一个生成器对象。也就是说，生成器函数是生成器工厂。</p><h2 id="14-5-惰性实现"><a href="#14-5-惰性实现" class="headerlink" title="14.5 惰性实现"></a>14.5 惰性实现</h2><p>惰性求值(laze evaluation)和及早求值(eager evaluation)是两个相反的方法。  </p><p><code>re.finditer</code>函数是<code>re.findall</code>的惰性版本，返回的不是一个列表，而是一个生成器，按需生成<code>re.MatchObject</code>实例。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> reprlib</span><br><span class="line"></span><br><span class="line">RE_WORD = re.compile(<span class="string">'\w+'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sentence</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.text = text</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Sentence(%s)'</span> % reprlib.repr(self.text)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> match <span class="keyword">in</span> RE_WORD.finditer(self.text):</span><br><span class="line">            <span class="keyword">yield</span> match.group()</span><br></pre></td></tr></table></figure></p><p><code>match.group()</code>方法从MatchObject实例中提取匹配正则表达式的具体文本。</p><h2 id="14-6-生成器表达式"><a href="#14-6-生成器表达式" class="headerlink" title="14.6 生成器表达式"></a>14.6 生成器表达式</h2><p>简单的生成器函数可以替换为生成器表达式。<br>生成器表达式可以理解为列表推到的惰性版本：不会迫切的构建列表，而是返回一个生成器，惰性按需生成元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (match.group() <span class="keyword">for</span> match <span class="keyword">in</span> RE_WORD.finditer(self.text))</span><br></pre></td></tr></table></figure><p><strong>如果生成器表达式要分成多行写，倾向于定义生成器函数，以便提高可读性。此外，生成器函数有名称，可以重用。</strong></p><h2 id="14-9-标准库中的生成器函数"><a href="#14-9-标准库中的生成器函数" class="headerlink" title="14.9 标准库中的生成器函数"></a>14.9 标准库中的生成器函数</h2><blockquote><p>p349 - p356</p></blockquote><blockquote><p><code>itertools.dropwhile</code> would stop dropping when failed and take the rest.<br><code>itertools.takewhile</code> wound stop taking when failed and drop the rest.</p></blockquote><h2 id="14-12-深入分析iter函数"><a href="#14-12-深入分析iter函数" class="headerlink" title="14.12 深入分析iter函数"></a>14.12 深入分析iter函数</h2><p><code>iter</code>函数可以传入两个参数，第一个参数是可调用对象， 用于不断调用，产出各个值；第二个参数是哨符，当可调用对象返回这个值时，触发迭代器抛出<code>StopIteration</code>异常，而<strong>不产出哨符</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;包括对象(第8、9章)、序列(第10章)、接口（第11章）、继承（第12章）、重载运算符（第13章）和生成器（第14章）&lt;br&gt;
    
    </summary>
    
    
      <category term="Fluent Python" scheme="https://soundquiet.github.io/categories/Fluent-Python/"/>
    
    
      <category term="Python" scheme="https://soundquiet.github.io/tags/Python/"/>
    
      <category term="读书笔记" scheme="https://soundquiet.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Fluent Python 读书笔记(3)</title>
    <link href="https://soundquiet.github.io/2018/10/14/Fluent-Python-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-3/"/>
    <id>https://soundquiet.github.io/2018/10/14/Fluent-Python-读书笔记-3/</id>
    <published>2018-10-14T06:56:25.000Z</published>
    <updated>2018-10-14T06:59:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>包括使用一等函数实现设计模式(第6章)和装饰器(第7章)<br><a id="more"></a></p><h1 id="Chap-6-使用一等函数实现设计模式"><a href="#Chap-6-使用一等函数实现设计模式" class="headerlink" title="Chap 6 使用一等函数实现设计模式"></a>Chap 6 使用一等函数实现设计模式</h1><h2 id="6-1-“策略”模式"><a href="#6-1-“策略”模式" class="headerlink" title="6.1 “策略”模式"></a>6.1 “策略”模式</h2><p><strong>策略</strong>模式是定义一系列算法，将它们一一封装起来，并且使它们可以相互替换。本模式使得算法可以独立于使用它的客户而变化。<br><img src="/images/blogs/FluentPython/strategy.png" alt></p><ul><li>上下文 context<br>把一些计算委托给实现不同算法的可互换组件，它提供服务。</li><li>策略 strategy<br>实现不同算法的组件的共同接口</li><li>具体策略<br>“策略”的具体子类</li></ul><p>在经典的“策略”模式中，具体策略都是一个类，它们没有状态，只有一个函数，可以用函数重构。</p><blockquote><p>策略对象通常是很好的享元。<br>享元是可共享的对象，可以同时在多个上下文中使用。</p></blockquote><p>共享是推荐的做法，这样不用在多个上下文中使用相同的策略时不断新建具体策略对象，减少消耗。<br>函数比用户定义的类轻量级，而且无需使用“享元”模式，因为各个策略函数字Python编译模块时只会创建一次。</p><h2 id="6-2-“命令”模式"><a href="#6-2-“命令”模式" class="headerlink" title="6.2 “命令”模式"></a>6.2 “命令”模式</h2><p><strong>命令</strong>模式的目的是解耦调用操作的对象（调用者）和提供实现的对象（接收者）。  </p><p>利用一等函数重构命令模式的方法与策略模式相似：将实现单方法接口的类的实例替换为可调用对象。</p><h1 id="Chap-7-函数装饰器和闭包"><a href="#Chap-7-函数装饰器和闭包" class="headerlink" title="Chap 7 函数装饰器和闭包"></a>Chap 7 函数装饰器和闭包</h1><h2 id="7-1-装饰器基础知识"><a href="#7-1-装饰器基础知识" class="headerlink" title="7.1 装饰器基础知识"></a>7.1 装饰器基础知识</h2><p>装饰器是可调用的对象，其参数是另一个函数（被装饰的函数）。装饰器可能会处理被装饰的函数，然后将它返回，或者将其替换成另一个函数或者可调用对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deco</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'running inner()'</span>)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="meta">@deco</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">target</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'running target()'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>target()</span><br><span class="line">running inner()</span><br></pre></td></tr></table></figure><p>此时的target()是对inner()的引用。</p><h2 id="7-2-Python何时执行装饰器"><a href="#7-2-Python何时执行装饰器" class="headerlink" title="7.2 Python何时执行装饰器"></a>7.2 Python何时执行装饰器</h2><p>装饰器在被装饰的函数定义之后立即运行，即<strong>导入时</strong>（Python加载模块时）。<br>函数装饰器在导入模块时立即执行，而被装饰的函数只在明确调用时运行。</p><p>装饰器常有以下用法：</p><ul><li>装饰器通常在一个模块中定义，然后应用到其他模块的函数上</li><li>大多数装饰器会在内部定义一个函数，然后将其返回</li></ul><h2 id="7-4-变量作用域规则"><a href="#7-4-变量作用域规则" class="headerlink" title="7.4 变量作用域规则"></a>7.4 变量作用域规则</h2><p>Python不要求声明变量，但是假定在函数定义体中赋值的变量是局部变量。</p><p>在函数中复制时想让解释器将变量当成全局变量，使用<code>global</code>声明。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">b = <span class="number">6</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f3</span><span class="params">(a)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> b</span><br><span class="line">    print(a)</span><br><span class="line">    print(b)</span><br><span class="line">    b = <span class="number">9</span></span><br></pre></td></tr></table></figure></p><h2 id="7-5-闭包"><a href="#7-5-闭包" class="headerlink" title="7.5 闭包"></a>7.5 闭包</h2><p><strong>闭包</strong>指延伸了作用域的函数，其中包含<strong>定义体内引用、但是不在定义体中定义的非全局变量</strong>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_average</span><span class="params">()</span>:</span></span><br><span class="line">    series = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">(new_value)</span>:</span></span><br><span class="line">        series.append(new_value)</span><br><span class="line">        total = sum(series)</span><br><span class="line">        <span class="keyword">return</span> total / len(series)</span><br><span class="line">    <span class="keyword">return</span> averager</span><br></pre></td></tr></table></figure></p><p><code>series</code>是自由变量（指未在本地作用域中绑定的变量）</p><p><code>series</code>的绑定在返回<code>avg</code>函数的<code>__closure__</code>属性中，<code>avg.__closure__</code>中的各个元素对应于<code>avg.__code__.co_freevars</code>中的一个名称。这些元素是cell对象，有个<code>cell_contents</code>属性，保存着真正的值。</p><p>闭包是一种函数，它会保留定义函数时存在的自由变量的绑定，这样调用函数时，虽然定义作用域不可用了，但是仍能使用那些绑定。</p><h2 id="7-6-nonlocal声明"><a href="#7-6-nonlocal声明" class="headerlink" title="7.6 nonlocal声明"></a>7.6 nonlocal声明</h2><p>如果将7.5中的程序修改为只保存总值和个数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_average</span><span class="params">()</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">(new_value)</span>:</span></span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        total += new_value</span><br><span class="line">        <span class="keyword">return</span> total / count</span><br><span class="line">    <span class="keyword">return</span> averager</span><br></pre></td></tr></table></figure></p><p>这样的代码是，<code>count+=1</code>的操作相当于对count赋值，把count当作局部变量，会出现未声明先引用的问题。在7.5的代码中，<strong>列表是可变的对象</strong>使得这个问题不会出现，但是<strong>数字、字符串、元组</strong>等是不可变类型，只能读取，不能更新。</p><p>为了解决这个问题，Python 3 引入了<code>nonlocal</code>声明，将变量标记为自由变量<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_average</span><span class="params">()</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">(new_value)</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> count, total</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        total += new_value</span><br><span class="line">        <span class="keyword">return</span> total / count</span><br><span class="line">    <span class="keyword">return</span> averager</span><br></pre></td></tr></table></figure></p><h2 id="7-8-标准库中的装饰器"><a href="#7-8-标准库中的装饰器" class="headerlink" title="7.8 标准库中的装饰器"></a>7.8 标准库中的装饰器</h2><h3 id="functools-wraps"><a href="#functools-wraps" class="headerlink" title="functools.wraps"></a>functools.wraps</h3><p>协助构建行为良好的装饰器</p><h3 id="functools-lru-cache"><a href="#functools-lru-cache" class="headerlink" title="functools.lru_cache"></a>functools.lru_cache</h3><p>实现了备忘功能，是一项优化技术，把耗时的函数的结果保存起来，避免传入相同的参数时重复计算（eg: 斐波那契数递归函数）<br>LRU是Least Recently Used的缩写<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="keyword">from</span> clockdeco <span class="keyword">import</span> clock</span><br><span class="line"><span class="meta">@functools.lru_cache()</span></span><br><span class="line"><span class="meta">@clock</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span> :</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">return</span> fibonacci(n<span class="number">-2</span>) + fibonacci(n<span class="number">-2</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(fibonacci(<span class="number">6</span>))</span><br></pre></td></tr></table></figure></p><h3 id="单分派泛函数"><a href="#单分派泛函数" class="headerlink" title="单分派泛函数"></a>单分派泛函数</h3><p><code>functools.singledispatch</code>装饰器将整体方案拆分成多个模块，甚至可以为你无法修改的类提供专门的函数。<br>使用<code>@singledispatch</code>装饰的普通函数会变成泛函数：根据第一个参数的类型，以不同方式执行相同操作的一组函数，</p><h2 id="7-9-叠放装饰器"><a href="#7-9-叠放装饰器" class="headerlink" title="7.9 叠放装饰器"></a>7.9 叠放装饰器</h2><p>把<code>@d1</code>和<code>@d2</code>两个装饰器按顺序应用到<code>f</code>函数上，作用相当于<code>f = d2(d2(f))</code></p><h2 id="7-10-参数化装饰器"><a href="#7-10-参数化装饰器" class="headerlink" title="7.10 参数化装饰器"></a>7.10 参数化装饰器</h2><p>Python会将被装饰函数作为第一个参数传给装饰器，要传入其他参数，需要创建一个装饰器工厂函数，把参数传给他，返回一个装饰器，然后再把它应用到要装饰的函数上。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">registry = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">(active = True)</span>:</span> <span class="comment">#装饰器工厂函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorate</span><span class="params">(func)</span>:</span> <span class="comment">#装饰器</span></span><br><span class="line">        print(<span class="string">'running register(active=%s)-&gt;decorete(%s)'</span> % (active, func)) <span class="comment"># 从闭包中获取active的值</span></span><br><span class="line">        <span class="keyword">if</span> active :</span><br><span class="line">            registry.add(func)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            registry.discard(func)</span><br><span class="line">        <span class="keyword">return</span> func <span class="comment"># 装饰器返回函数</span></span><br><span class="line">    <span class="keyword">return</span> decorate <span class="comment"># 返回装饰器</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@register(active=False) </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'running f1()'</span>)</span><br><span class="line"><span class="meta">@register()  # 工厂函数必须作为函数调用</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'running f2()'</span>)</span><br></pre></td></tr></table></figure><p>如果要想常规函数使用<code>register</code>，将<code>f</code>添加到<code>registry</code>中，需要使用<code>register()(f)</code>或<code>register(active=False)(f)</code>（删除/不想添加）</p><p>参数化装饰器通常会把被装饰的函数替换掉，而且结构上需要多一层嵌套</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;包括使用一等函数实现设计模式(第6章)和装饰器(第7章)&lt;br&gt;
    
    </summary>
    
    
      <category term="Fluent Python" scheme="https://soundquiet.github.io/categories/Fluent-Python/"/>
    
    
      <category term="Python" scheme="https://soundquiet.github.io/tags/Python/"/>
    
      <category term="读书笔记" scheme="https://soundquiet.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Data Visualization and D3.js 笔记(5)</title>
    <link href="https://soundquiet.github.io/2018/10/14/Data-Visualization-and-D3-js-%E7%AC%94%E8%AE%B0-5/"/>
    <id>https://soundquiet.github.io/2018/10/14/Data-Visualization-and-D3-js-笔记-5/</id>
    <published>2018-10-14T06:49:31.000Z</published>
    <updated>2018-10-14T06:54:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>Lesson 7讲了获取数据的途径、叙事结构的种类和用D3.js编程的实例.<br><a id="more"></a></p><h1 id="Lesson-7-叙事结构"><a href="#Lesson-7-叙事结构" class="headerlink" title="Lesson 7 叙事结构"></a>Lesson 7 叙事结构</h1><h2 id="相关性与因果关系"><a href="#相关性与因果关系" class="headerlink" title="相关性与因果关系"></a>相关性与因果关系</h2><p><strong>相关性</strong>，correlation，A AND B<br><strong>因果关系</strong>，causation，A -&gt; B  </p><p>A与B具有相关性不意味着它们有相关性。</p><h2 id="新新闻主义"><a href="#新新闻主义" class="headerlink" title="新新闻主义"></a>新新闻主义</h2><p>更开放，故事是为数据而服务的，媒介通常是动态网页。</p><p>传统数据新闻通常是用图表做故事叙述的辅佐，通常是静态网页、报刊杂志等。</p><h2 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h2><p><a href="http://datajournalismhandbook.org/1.0/en/getting_data_0.html" target="_blank" rel="noopener">A Five Minute Field Guide</a><br>如何获取想要的数据：</p><ol><li>精简搜索(Google)<ul><li>搜索时包括数据内容和数据格式 eg: ‘filetype: xls’</li><li>搜索部分URL eg: ‘inurl: downloads filetype:xls’ 会返回所有在地址中含’downloads’的xls文件</li><li>不直接搜索内容， 而搜索可能存在目标数据的地方</li></ul></li><li><p>浏览数据网站或服务机构</p><blockquote><p>Official data portals. The government’s willingness to release a given dataset will vary from country to country. A growing number of countries are launching data portals (inspired by the U.S.’s data.gov and the U.K.’s data.gov.uk) to promote the civic and commercial re-use of government information. An up-to-date, global index of such sites can be found at datacatalogs.org. Another handy site is the Guardian World Government Data, a meta search engine that includes many international government data catalogues.</p><p>The Data Hub. A community-driven resource run by the Open Knowledge Foundation that makes it easy to find, share and reuse openly available sources of data, especially in ways that are machine-automated.</p><p>ScraperWiki. an online tool to make the process of extracting “useful bits of data easier so they can be reused in other apps, or rummaged through by journalists and researchers.” Most of the scrapers and their databases are public and can be re-used.</p><p>The World Bank and United Nations data portals provide high-level indicators for all countries, often for many years in the past.</p><p>A number of startups are emerging, that aim to build communities around data sharing and re-sale. This includes Buzzdata — a place to share and collaborate on private and public datasets — and data shops such as Infochimps and DataMarket.</p><p>DataCouch — A place to upload, refine, share &amp; visualize your data.</p><p>An interesting Google subsidiary, Freebase, provides “an entity graph of people, places and things, built by a community that loves open data.”</p><p>Research data. There are numerous national and disciplinary aggregators of research data, such as the UK Data Archive. While there will be lots of data that is free at the point of access, there will also be much data that requires a subscription, or which cannot be reused or redistributed without asking permission first.</p></blockquote></li><li><p>利用论坛发问比如getthedata.org或Quora</p></li></ol><hr><p><a href="http://datajournalismhandbook.org/1.0/en/getting_data_3.html" target="_blank" rel="noopener">Getting Data from the Web</a><br>如果无法直接获取数据库，可以从网络上收集。</p><h2 id="利用图表撒谎"><a href="#利用图表撒谎" class="headerlink" title="利用图表撒谎"></a>利用图表撒谎</h2><ol><li>柱状图的y轴应从0开始，线图可以不用</li><li>饼图会有混淆效果，可用<strong>堆叠条形图</strong>改进，以展示100%的数据意义</li><li>线图的样本点采用、y轴起点可能会影响数据展示效果</li></ol><h2 id="偏差类型"><a href="#偏差类型" class="headerlink" title="偏差类型"></a>偏差类型</h2><ol><li>作者偏差<br>利用visual encoding有意无意地篡改数据（图标撒谎）</li><li>数据偏差<br>产生于数据收集过程</li><li>读者偏差<br>读者的先入观念</li></ol><h2 id="叙事结构"><a href="#叙事结构" class="headerlink" title="叙事结构"></a>叙事结构</h2><ol><li>Author-Driven Narratives<br>(常用于传统数据新闻叙述)<br><img src="/images/blogs/dv&amp;d3/lesson7/author-driven.png" alt><br>特点：  </li></ol><ul><li>strong ordering</li><li>heavy messaging</li><li>need for clarity &amp; speed</li></ul><ol start="2"><li>Viewer-Driven Naarratives<br>常用于新新闻主义<br><img src="/images/blogs/dv&amp;d3/lesson7/viewer-driven.png" alt><br>特点：</li></ol><ul><li>viewers ask question on their own</li><li>explore data</li><li>tell their own story</li></ul><ol start="3"><li>Martini Glass<br>更加复杂的Data Visualization，是上述二者的结合，先线性叙述，然后让读者自己探索数据。</li></ol><h2 id="揭秘D3-js"><a href="#揭秘D3-js" class="headerlink" title="揭秘D3.js"></a>揭秘D3.js</h2><h3 id="绑定数据"><a href="#绑定数据" class="headerlink" title="绑定数据"></a>绑定数据</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d3.select(<span class="string">'svg'</span>)</span><br><span class="line">  .selectAll(<span class="string">'circle'</span>)</span><br><span class="line">  .data(data)</span><br><span class="line">  .enter()</span><br><span class="line">  .append(<span class="string">'circle'</span>)</span><br></pre></td></tr></table></figure><p>在未进行这段代码之前，<code>selectAll(&#39;circle&#39;)</code>返回的应该是空集，那么数据绑定到哪了?<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d3.select(<span class="string">'svg'</span>) <span class="comment">// select a container svg element on the page</span></span><br><span class="line">  .selectAll(<span class="string">'circle'</span>) <span class="comment">// create an empty selection to bind data</span></span><br><span class="line">  .data(data) <span class="comment">// bind data to the empty selection</span></span><br><span class="line">  .enter() <span class="comment">// select all bound data elements not displayed</span></span><br><span class="line">  .append(<span class="string">'circle'</span>) <span class="comment">// create svg element for the bound data</span></span><br></pre></td></tr></table></figure></p><p>d3在与空集绑定数据时，会创建虚拟占位符来关联至数据得每一行。</p><h3 id="enter-amp-amp-exit"><a href="#enter-amp-amp-exit" class="headerlink" title="enter() &amp;&amp; exit()"></a>enter() &amp;&amp; exit()</h3><p><img src="/images/blogs/dv&amp;d3/lesson7/exit.png" alt><br><code>update</code>代表当前存在于html中，之前进行data绑定的元素<br><code>exit()</code>代表<code>enter()</code>的方面，表示html元素未与数据做绑定。用途：</p><ul><li>去除不再显示的元素</li><li>在不同时间点的数据存在变化的动画中使用</li><li>在初次绘制图表且拥有可供用户选择根据某个类别筛选的子选项时使用</li></ul><h3 id="使用D3-js绘制坐标轴"><a href="#使用D3-js绘制坐标轴" class="headerlink" title="使用D3.js绘制坐标轴"></a>使用D3.js绘制坐标轴</h3><ol><li>定义区间<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> time_extent = d3.extent(data, <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> d.date;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> count_extent = d3.extent(data, <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> d.attendance;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><p>为了安全，将日期数据转为JavaScript的日期对象，可以使用内置函数进行转换：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">format = <span class="string">"..."</span> <span class="comment">// 定义格式</span></span><br><span class="line">d3.tsv(<span class="string">"..."</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">    d.date = format.parse(d.date);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><ol start="2"><li><p>将数据从初始值映射到实际的像素点</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> time_scale = d3.time.scale()</span><br><span class="line">                    .range([margin, width])</span><br><span class="line">                    .domain(time_extent);</span><br><span class="line"><span class="keyword">var</span> count_scale = d3.scale.linear()</span><br><span class="line">                    .range([height, margin])</span><br><span class="line">                    .domain(count_scale);</span><br></pre></td></tr></table></figure></li><li><p>绘制轴</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> time_axis = d3.svg.axis()</span><br><span class="line">                .scale(time_scale)</span><br><span class="line">                .ticks(d3.time.years, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> count_axis = d3.svg.axis()</span><br><span class="line">                .scale(count_scale)</span><br><span class="line">                .orient(<span class="string">"left"</span>); <span class="comment">// 将刻度绘制在轴路径的左边</span></span><br><span class="line">d3.select(<span class="string">'svg'</span>)</span><br><span class="line">  .append(<span class="string">'g'</span>)</span><br><span class="line">  .attr(<span class="string">'class'</span>, <span class="string">'x axis'</span>)</span><br><span class="line">  .attr(<span class="string">'transform'</span>, <span class="string">'translate(0, '</span> + height + <span class="string">')'</span>)</span><br><span class="line">  .call(time_axis)</span><br><span class="line">d3.select(<span class="string">'svg'</span>)</span><br><span class="line">  .append(<span class="string">'g'</span>)</span><br><span class="line">  .attr(<span class="string">'class'</span>, <span class="string">'y axis'</span>)</span><br><span class="line">  .attr(<span class="string">'transform'</span>, <span class="string">'translate('</span> + margin + <span class="string">'0)'</span>)</span><br><span class="line">  .call(count_axis)</span><br></pre></td></tr></table></figure></li></ol><p><code>call()</code>将存取对象传递值函数调用链。<br><code>transform</code>属性用于移动元素（这里是坐标轴）在<code>svg</code>中的位置。</p><h3 id="绘制legend"><a href="#绘制legend" class="headerlink" title="绘制legend"></a>绘制legend</h3><p>其实还是正常画法，D3.js没有专门的绘制legend的API。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> legend = svg.append(<span class="string">'g'</span>)</span><br><span class="line">                .attr(<span class="string">'class'</span>, <span class="string">'legend'</span>)</span><br><span class="line">                .attr(<span class="string">'transform'</span>, <span class="string">'translate('</span> + (width - <span class="number">30</span>) + <span class="string">','</span> + <span class="number">10</span> +<span class="string">')'</span>)</span><br><span class="line">                .selectAll(<span class="string">'g'</span>)</span><br><span class="line">                .data([<span class="string">'Home Team'</span>, <span class="string">'Others'</span>])</span><br><span class="line">                .enter()</span><br><span class="line">                .append(<span class="string">'g'</span>);</span><br><span class="line">legend.append(<span class="string">'circle'</span>)</span><br><span class="line">      .attr(<span class="string">'cy'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">30</span> * i;</span><br><span class="line">      &#125;)</span><br><span class="line">      .attr(<span class="string">'r'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(d == <span class="string">'Home Team'</span>)</span><br><span class="line">            <span class="keyword">return</span> radius * multiplier;</span><br><span class="line">          <span class="keyword">else</span>  <span class="keyword">return</span> radius;</span><br><span class="line">      &#125;);</span><br><span class="line">legend.append(<span class="string">'text'</span>)</span><br><span class="line">      .attr(<span class="string">'y'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> i * <span class="number">30</span> + <span class="number">5</span>;</span><br><span class="line">      &#125;)</span><br><span class="line">      .attr(<span class="string">'x'</span>, radius * <span class="number">5</span>)</span><br><span class="line">      .text(<span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> d;</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure></p><p>对于<code>text</code>元素来说，<code>x</code>和<code>y</code>定义了开始画文本的左下角的位置.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Lesson 7讲了获取数据的途径、叙事结构的种类和用D3.js编程的实例.&lt;br&gt;
    
    </summary>
    
    
      <category term="Data Visualization and D3.js" scheme="https://soundquiet.github.io/categories/Data-Visualization-and-D3-js/"/>
    
    
      <category term="data visualization" scheme="https://soundquiet.github.io/tags/data-visualization/"/>
    
      <category term="d3.js" scheme="https://soundquiet.github.io/tags/d3-js/"/>
    
  </entry>
  
  <entry>
    <title>Data Visualization and D3.js 笔记(4)</title>
    <link href="https://soundquiet.github.io/2018/10/14/Data-Visualization-and-D3-js-%E7%AC%94%E8%AE%B0-4/"/>
    <id>https://soundquiet.github.io/2018/10/14/Data-Visualization-and-D3-js-笔记-4/</id>
    <published>2018-10-14T06:45:49.000Z</published>
    <updated>2018-10-14T06:49:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>本节主要介绍了Dimple.js的用法(Lesson 5)，还有直方图与条形图的比较(Lesson 6)。<br><a id="more"></a></p><h1 id="Lesson-5-Dimple-js"><a href="#Lesson-5-Dimple-js" class="headerlink" title="Lesson 5 Dimple.js"></a>Lesson 5 Dimple.js</h1><h2 id="Dimple-js"><a href="#Dimple-js" class="headerlink" title="Dimple.js"></a>Dimple.js</h2><p>dimple.js is a powerful and flexible open-source charting API for d3 letting you quickly and easily create and combine bar, line, area and scatter charts.<br><a href="http://dimplejs.org/" target="_blank" rel="noopener">http://dimplejs.org/</a></p><h2 id="使用Dimple-js绘制柱状图"><a href="#使用Dimple-js绘制柱状图" class="headerlink" title="使用Dimple.js绘制柱状图"></a>使用Dimple.js绘制柱状图</h2><blockquote><p>先加载D3.js, 再加载Dimple.js</p></blockquote><h3 id><a href="#" class="headerlink" title></a><script></script></h3><ol><li>识别文本中代码块</li><li>使用<code>src</code>属性加载脚本文件</li></ol><h3 id="JavaScript调试器"><a href="#JavaScript调试器" class="headerlink" title="JavaScript调试器"></a>JavaScript调试器</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">debugger</span>;</span><br></pre></td></tr></table></figure><blockquote><p>代码中写有调试器，浏览器仍会完全加载？<br>——需要在加载页面前打开检查工具</p></blockquote><h3 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h3><p>AJAX 代表异步JavaScript和XM，指web页面在页面加载后进行HTTP请求的过程。</p><h3 id="use-strict"><a href="#use-strict" class="headerlink" title="use strict"></a>use strict</h3><p>指定代码在严格条件下执行，只允许出现在脚本或函数的开头。<br>在严格模式下：</p><ul><li>不能使用未声明的变量</li><li>不能删除变量、对象或函数</li><li>不允许变量重名</li><li>不允许使用八进制</li><li>变量名不能使用 “eval” 字符串</li><li>禁止this关键字只想全局对象</li></ul><h3 id="边缘惯例-Margin-Convention"><a href="#边缘惯例-Margin-Convention" class="headerlink" title="边缘惯例 Margin Convention"></a>边缘惯例 <a href="https://bl.ocks.org/mbostock/3019563" target="_blank" rel="noopener">Margin Convention</a></h3><ol><li><p>define the margin for 4 sides;</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> margin = &#123;<span class="attr">top</span>: <span class="number">20</span>, <span class="attr">right</span>: <span class="number">10</span>, <span class="attr">bottom</span>: <span class="number">20</span>, <span class="attr">left</span>: <span class="number">10</span>&#125;;</span><br></pre></td></tr></table></figure></li><li><p>define the width, height as inner dimensions of the chart area;</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> width = <span class="number">960</span> - margin.left - margin.right;</span><br></pre></td></tr></table></figure></li><li><p>define <code>svg</code> as a G element that translates the orgin to the top-left corner of the chart area.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> svg = d3.select(<span class="string">'body'</span>)</span><br><span class="line">            .append(<span class="string">'svg'</span>)</span><br><span class="line">            .attr(<span class="string">'width'</span>, width + margin.left + margin.right)</span><br><span class="line">            .attr(<span class="string">'height'</span>, height + margin.top + margin.bottom)</span><br><span class="line">            .append(<span class="string">'g'</span>)</span><br><span class="line">            .attr(<span class="string">'transform'</span>, <span class="string">'translate('</span> + margin.left + <span class="string">','</span> + margin.top + <span class="string">')'</span>);</span><br></pre></td></tr></table></figure></li></ol><h3 id="Code-for-Bar-Chart-Using-Dimple-js"><a href="#Code-for-Bar-Chart-Using-Dimple-js" class="headerlink" title="Code for Bar Chart Using Dimple.js"></a>Code for Bar Chart Using Dimple.js</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"utf-8"</span>&gt;</span><br><span class="line">    &lt;!-- d3.js 和 Dimple.js 的引用顺序--&gt;</span><br><span class="line">    &lt;script src=<span class="string">"http://d3js.org/d3.v3.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">    &lt;script src=<span class="string">"http://dimplejs.org/dist/dimple.v2.0.0.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            D3.js setup code</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"><span class="meta">            "use strict"</span>;</span><br><span class="line">            <span class="keyword">var</span> margin = <span class="number">75</span>,</span><br><span class="line">                width = <span class="number">1400</span> - margin,</span><br><span class="line">                height = <span class="number">600</span> - margin;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">debugger</span>; </span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> svg = d3.select(<span class="string">"body"</span>)</span><br><span class="line">                .append(<span class="string">"svg"</span>)</span><br><span class="line">                .attr(<span class="string">"width"</span>, width + margin)</span><br><span class="line">                .attr(<span class="string">"height"</span>, height + margin)</span><br><span class="line">                .append(<span class="string">'g'</span>)</span><br><span class="line">                .attr(<span class="string">'class'</span>,<span class="string">'chart'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            Dimple.js Chart construction code</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">            <span class="keyword">var</span> myChart = <span class="keyword">new</span> dimple.chart(svg, data);</span><br><span class="line">            <span class="keyword">var</span> x = myChart.addTimeAxis(<span class="string">"x"</span>, <span class="string">"year"</span>); </span><br><span class="line">            <span class="comment">// 在图中添加一列代表时间的x轴来表示年份数据</span></span><br><span class="line">            <span class="comment">// 定义x的数据类型是由addTimeSeries决定的连续时间值</span></span><br><span class="line">            <span class="comment">// 第一个参数x是目标轴</span></span><br><span class="line">            <span class="comment">// 第二个参数是数据所在列名</span></span><br><span class="line">            myChart.addMeasureAxis(<span class="string">"y"</span>, <span class="string">"attendance"</span>);</span><br><span class="line">            <span class="comment">// 规定了y轴的数据类型和所对应的数据</span></span><br><span class="line">            myChart.addSeries(<span class="literal">null</span>, dimple.plot.bar);</span><br><span class="line">            <span class="comment">// addSeries规定了图表类型</span></span><br><span class="line">            <span class="comment">// 第一个参数代表了用来聚合数据的类名，若不聚合数据为null</span></span><br><span class="line">            myChart.draw();</span><br><span class="line">            <span class="comment">// 在哪个图表上调用draw函数，就回返回哪个图标对象</span></span><br><span class="line">            <span class="comment">// var draw_chart = myChart.draw() ==&gt;</span></span><br><span class="line">            <span class="comment">// draw_chart === myChart</span></span><br><span class="line">            <span class="comment">// 在哪个对象上调用方法就回返回哪个对象，这是D3链式语法的机制。</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Use D3 (not dimple.js) to load the TSV file</span></span><br><span class="line"><span class="comment">        and pass the contents of it to the draw function</span></span><br><span class="line"><span class="comment">        调用d3.tsv()载入数据，当AJAX请求返回后，会以JavaScript对象形式将数据传入draw回调函数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    d3.tsv(<span class="string">"world_cup.tsv"</span>, draw); </span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure><h3 id="柱状图的优缺点"><a href="#柱状图的优缺点" class="headerlink" title="柱状图的优缺点"></a>柱状图的优缺点</h3><p>（在这个例子中）<br>优点：  </p><ol><li>突出显示缺少数据的年份（negative space）</li><li>比较</li></ol><p>缺点：</p><ol><li>图标布局刻板 –&gt; x轴是固有顺序的变量</li><li>Bar Chart适用于分类数据</li></ol><h2 id="EDA-amp-amp-Sketching-Data-Visualization"><a href="#EDA-amp-amp-Sketching-Data-Visualization" class="headerlink" title="EDA &amp;&amp; Sketching Data Visualization"></a>EDA &amp;&amp; Sketching Data Visualization</h2><p>EDA </p><ul><li>for insight</li><li>erroneous values</li><li>structure</li></ul><p>Sketching Data Visualization</p><ul><li>visual layout</li><li>visual encoding</li><li>others &amp; data</li></ul><h2 id="散点图的应用"><a href="#散点图的应用" class="headerlink" title="散点图的应用"></a>散点图的应用</h2><p>散点图更适用于x轴上各字段不相关的数据，eg：两个定量的关系（分布关系）</p><h1 id="Lesson-6-Exercise"><a href="#Lesson-6-Exercise" class="headerlink" title="Lesson 6 Exercise"></a>Lesson 6 Exercise</h1><h2 id="直方图-vs-条形图"><a href="#直方图-vs-条形图" class="headerlink" title="直方图 vs. 条形图"></a>直方图 vs. 条形图</h2><p>直方图是表示在连续间隔、或者特定时间段内数据分布情况的图表，描述了一组数据的频次<strong>分布</strong>。</p><p>条形图更多表示数据的<strong>大小</strong></p><p><img src="/images/blogs/dv&amp;d3/lesson6/vs.png" alt></p><h2 id="频次多边形-Frequency-Polygon"><a href="#频次多边形-Frequency-Polygon" class="headerlink" title="频次多边形 Frequency Polygon"></a>频次多边形 Frequency Polygon</h2><p>次数分布图的一种，用于描述一组数据的次数分布，与直方图作用相同。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本节主要介绍了Dimple.js的用法(Lesson 5)，还有直方图与条形图的比较(Lesson 6)。&lt;br&gt;
    
    </summary>
    
    
      <category term="Data Visualization and D3.js" scheme="https://soundquiet.github.io/categories/Data-Visualization-and-D3-js/"/>
    
    
      <category term="data visualization" scheme="https://soundquiet.github.io/tags/data-visualization/"/>
    
      <category term="d3.js" scheme="https://soundquiet.github.io/tags/d3-js/"/>
    
  </entry>
  
  <entry>
    <title>Data Visualization and D3.js 笔记(3)</title>
    <link href="https://soundquiet.github.io/2018/09/29/Data-Visualization-and-D3-js-%E7%AC%94%E8%AE%B0-3/"/>
    <id>https://soundquiet.github.io/2018/09/29/Data-Visualization-and-D3-js-笔记-3/</id>
    <published>2018-09-29T08:41:32.000Z</published>
    <updated>2019-10-30T07:14:17.346Z</updated>
    
    <content type="html"><![CDATA[<p>这一节(Lesson 4)更多关注一些设计的概念和注意事项。<br><a id="more"></a></p><h1 id="Lesson-4-设计原则"><a href="#Lesson-4-设计原则" class="headerlink" title="Lesson 4 设计原则"></a>Lesson 4 设计原则</h1><h2 id="图表类型"><a href="#图表类型" class="headerlink" title="图表类型"></a>图表类型</h2><p>Visualization for data science is:</p><ol><li>simple solution to solve problems</li><li>choose the right tool (chart)</li></ol><p><img src="/images/blogs/dv&amp;d3/lesson4/chartchooserincolor.jpg" alt></p><ul><li><a href="http://www.perceptualedge.com/articles/ie/the_right_graph.pdf" target="_blank" rel="noopener">Selecting the Right Graph for Your Message </a></li><li><a href="http://labs.juiceanalytics.com/chartchooser/index.html" target="_blank" rel="noopener">interactive chart chooser </a></li><li><a href="http://www.perceptualedge.com/images/Effective_Chart_Design.pdf" target="_blank" rel="noopener">Designing Effective Tables and Graphs</a>  <ul><li>table works best when<ul><li>it is used to look up individual values</li><li>the values must be compared</li></ul></li><li>graph works best when<ul><li>the message is contained in the shape of data (pattren, trends, exceptions to the norm)</li><li>entire sets of values must be compared</li></ul></li></ul></li></ul><blockquote><p>Visual Encoding + Data Types + Relationships (between data) = Chart Type</p></blockquote><h3 id="选择图表类型"><a href="#选择图表类型" class="headerlink" title="选择图表类型"></a>选择图表类型</h3><p>可以从两个角度考虑：</p><ol><li>Data Type<ul><li>Continuous</li><li>Categorical</li></ul></li><li>Dimension of data<ul><li>1D</li><li>2D</li><li>3D</li></ul></li></ol><h3 id="图表的着重点"><a href="#图表的着重点" class="headerlink" title="图表的着重点"></a>图表的着重点</h3><ol><li><p>条形图 bar chart — 突出显示单个值，支持对比，可以呈现排名或偏差</p></li><li><p>箱线图 boxplot - 呈现分布和分位数，在对比分布时尤其有用</p></li><li><p>饼状图 pie chart - 呈现部分到整体的关系，最适合一个类别；不适合进行对比</p></li><li><p>堆栈条形图 stacked bar chart - 呈现部分到整体的关系，最适合呈现类别和总量的构成</p></li><li><p>气泡图 bubble chart - 呈现三组以上的值如何变化；呈现相关性</p></li><li><p>线条图 line chart - 通常在相等的时间间隔上，呈现整体变化和模式</p></li><li><p>地图 map - 在物理位置上将值进行编码，并且可通过对比位置来绘制模式</p></li><li><p>散点图 scatterplot - 呈现两组配对的值（例如：身高和鞋码）如何变化；呈现相关性</p></li><li><p>小多组图 Small Multiples - 分布在一个坐标方格上的一系列图，通常用于展示同一组数据的各个方面（比较）</p></li><li><p>箱型图 Box Plot - 一组箱型图在一个图表中对不同分布情况进行可视化</p></li></ol><blockquote><p>小多组图和箱型图可用于EDA，了解数据分布情况</p></blockquote><ol start="11"><li><p>表格 Table - 不属于传统意义上的可视化工具，可以对离散的事实、或者没有固有结构或顺序的数据进行展示。可以清楚的看到每一个数据</p></li><li><p>地图 Map - 可以和其他Visual Encoding方式结合展示地理上的数据</p></li><li><p><a href="http://www.perceptualedge.com/articles/misc/Bullet_Graph_Design_Spec.pdf" target="_blank" rel="noopener">子弹图</a> - Stephen Few 开发的子弹图是用来替换仪表和量表的，因为它们占用了信息中心太多的宝贵空间。你可以在 wikipedia 上详细了解子弹图。</p></li><li><p><a href="http://www.edwardtufte.com/bboard/q-and-a-fetch-msg?msg_id=0001OR" target="_blank" rel="noopener">波形图</a> - Edward Tufte 发明的这些袖珍图形，用于在小型图表区域内包含大量信息。通过查看波形图，读者可以快速了解历史趋势、异态和指标的当前状态。你可以在 wikipedia 上详细了解波形图。</p></li><li><p><a href="http://www.perceptualedge.com/articles/guests/intro_to_cycle_plots.pdf" target="_blank" rel="noopener">循环图</a> - 最初由 Cleveland、Dunn 和 Terpenning 于 1978 年创造。与传统的线条图相比，循环图能够以不同的方式调查时间序列数据。</p></li><li><p><a href="http://www.thefunctionalart.com/2012/09/in-praise-of-connected-scatter-plots.html" target="_blank" rel="noopener">关联散点图</a> - 回想一下 Gapminder 数据可视化。在没有动画的帮助下，你可否揭示出随着年份变化的数据中隐藏的模式？ Alberot Cairo says “Yes!”. Alberto praises connected scatter plots and shares examples of them on his blog, The Functional Art. Alberot Cairo 说：“可以！”。Alberto 赞美了关联散点图，并且在他的博客 <a href="www.thefunctionalart.com">The Functional Art</a> 中分享了一些示例。</p></li><li><p>小提琴图 - 小提琴图类似于箱线图，唯一区别的是小提琴图在不同的值上呈现数据的概率密度。Nathan Yau 在他的博客 Flowing Data 上描述了<a href="http://flowingdata.com/2012/05/15/how-to-visualize-and-compare-distributions/" target="_blank" rel="noopener">可视化和对比分布</a>的小提琴图和其他方法。</p></li></ol><h2 id="Pre-attentive-Processing-前意识加工"><a href="#Pre-attentive-Processing-前意识加工" class="headerlink" title="Pre-attentive Processing 前意识加工"></a>Pre-attentive Processing 前意识加工</h2><p>前意识加工利用人的视觉和感知能力自动处理，来快速识别可视化中的元素。 通常需要200-250毫秒，约等于人们通过面部识别情绪的市场一样。</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ol><li>Color<ul><li>Color Hue</li><li>Color Intensity</li></ul></li><li>Form (Shape)</li><li>Movement  动态，如Fade in/out, 闪烁</li><li>Spacial Positon</li></ol><p>属性之间可以结合使用</p><p><strong>参考</strong></p><ul><li><a href="http://www.infovis.net/printMag.php?num=179&amp;lang=2" target="_blank" rel="noopener">Processes that pop out</a></li><li><a href="http://www.perceptualedge.com/articles/ie/visual_perception.pdf" target="_blank" rel="noopener">Tapping the Power of Visual Perception</a></li></ul><h2 id="负空间"><a href="#负空间" class="headerlink" title="负空间"></a>负空间</h2><p>负空间指在物体的形状之间或周围形成的。</p><p><strong>负空间</strong> 或 <strong>空白空间White Space</strong>的利用，可以使：</p><ul><li>you can communicate more elegantly, and create design that has a more “clean” look</li><li>you’ll be less likely to use extraneous ornamentation such as rule lines</li><li>you’ll be less likely to change fonts and colors just to differentiate pieces of information in your design.</li></ul><blockquote><p><a href="https://designforhackers.com/blog/whitespace-113/" target="_blank" rel="noopener">Designing with White Space: Why 1+1=3</a></p></blockquote><h2 id="零数据和缺失数据"><a href="#零数据和缺失数据" class="headerlink" title="零数据和缺失数据"></a>零数据和缺失数据</h2><ol><li><p>无标识<br>像著名的霍乱地图中，Brewery街道上没有染上霍乱的人，没有对应的图形。<br><img src="/images/blogs/dv&amp;d3/lesson4/missingdata_1.jpg" alt></p></li><li><p>用颜色标识<br>比如，<a href="https://www.theguardian.com/world/interactive/2012/may/08/gay-rights-united-states" target="_blank" rel="noopener">Gay rights in the US, state by state</a>, 使用灰色来表示未有对应法律</p></li></ol><h2 id="颜色的使用"><a href="#颜色的使用" class="headerlink" title="颜色的使用"></a>颜色的使用</h2><p>颜色有时会干扰用户，如果颜色的选择本身没有理由，观众会思考颜色代表的意义（尽管没有），即给图像带带了冗余信息。</p><ol><li>Get it right in black and white (and grey shade).</li><li>Use meduim hues or pastles(轻淡柔和的色彩)</li><li>Use color to highlight</li></ol><h3 id="双重编码"><a href="#双重编码" class="headerlink" title="双重编码"></a>双重编码</h3><p>有时候，双重编码在 <a href="https://archive.nytimes.com/www.nytimes.com/interactive/2012/05/17/business/dealbook/how-the-facebook-offering-compares.html?_r=1" target="_blank" rel="noopener">Facebook IPO</a> 等图形中可能会有所帮助。散点图较为复杂，因此双重编码（比如：沿 x 轴的颜色和位置）可以帮助读者理解数据。</p><h3 id="颜色使用规则-by-Stephen-Few"><a href="#颜色使用规则-by-Stephen-Few" class="headerlink" title="颜色使用规则 by Stephen Few"></a><a href="http://www.perceptualedge.com/articles/visual_business_intelligence/rules_for_using_color.pdf" target="_blank" rel="noopener">颜色使用规则</a> by Stephen Few</h3><p>Perception of an object is influenced by the context that surrounds it.<br>Visual perception is relative, not absolute.</p><font color="#A74824"><strong>Rule #1</strong><br>If you want different objects of the same color in a table or graph to look the same, make sure that the background – the color that surrounds them is consistent. </font><font color="#A74824"><strong>Rule #2</strong><br>If you want objects in a table or graph to be easily seen, use a background color that contrasts sufficiently with the object. </font><font color="#A74824"><strong>Rule #3</strong><br>Use color only when needed to serve a particular communication goal. </font><br>Don’t use color to <strong>decorate</strong> the display.<br><br><font color="#A74824"><strong>Rule #4</strong><br>Use different colors only when the correspond to differences of meaning in the data. </font><br>We use color effectively for three fundamental purposes in data display to promote communication:<br> - to highlight particular data<br> - to group items<br> - to encode quantitative values<br><br><font color="#A74824"><strong>Rule #5</strong><br>Use soft, natural colors to display most information and bright and/or dark colors to highlight information that requires greater attention. </font><br>In order to save time of picking colors, pre-set three palettes:<br>- one of bright, dark colors<br>- another of medium shades that are easy on eyes<br>- a final set of light, pale colors.<br><br>When objects are small or thin, colors should be brighter and/or darker than otherwise necessary.<br><br>Stephen provides three set of palettes sample.<br>Or we can use <a href="http://colorbrewer2.org/#type=sequential&amp;scheme=BuGn&amp;n=3" target="_blank" rel="noopener">Color Brewer</a>, a simple Web-based application to save time.<br>ColorBrewer divided palettes into three types:<br>- Categorical - separate items into distinct groups<br>- Sequential - encode quantitative differences sequentially, from low to high or high to low<br>- Diverging - encode quantitative differences form high to low then to high (or opposite)<br><br><font color="#A74824"><strong>Rule #6</strong><br>When using color to encode a sequential rage of quantitative values, stick with a single hue (or a small set of closelly related hues) and vary intensity from pale colors for low values to increasingly darker and brighter colors for high values.</font><br>Keeping the numbers turned off (invisible) while exploring the data works best.<br><br><font color="#A74824"><strong>Rule #7</strong><br>Non-data components of tables and graphs should be displayed just visibly enough to perform their role, but not more so, for excessive salience could cause them to distract attention from the data. </font><br>In graphs, the most common non-data objects are axis lines (excluding tick marks and labels, which do encode data), background fill colors, and borders (for example, around the plot area or legend).<br><br>| Component | Default Color |<br>| ——| —— |<br>| Axis lines | Use thin gray lines of medium intensity.|<br>| Borders | Whether around the graph as a whole, its plot area, or a legend, when borders are needed (and usually they are not), use thin gray lines of medium intensity.|<br>| Background | Use white (or in Excel select “None” for color).|<br>| Bars | Use a distinct hue of medium intensity for each data series.|<br>| Lines | For thin lines, use a distinct hue of fairly high intensity for each; otherwise, use distinct hues of medium intensity.|<br>| Data Points | For small points, use a distinct hue of fairly high intensity for each; otherwise, use distinct hues of medium intensity|<br><br><font color="#A74824"><strong>Rule #8</strong><br>To guarantee that most people who are colorblind can distinguish groups of data that are color coded, avoid using a combination of red and green in the same display. </font><br>为了尊重红绿色盲，应避免使用标准红/绿色<br>参考<a href="http://www.vizwiz.com/2013/02/improving-wsj-historical-us.html" target="_blank" rel="noopener">华尔街日报 (WSJ) 的美国失业率可视化图形-重新设计</a><br><br><font color="#A74824"><strong>Rule #9</strong><br>Avoid using visual effects in graphs.</font><blockquote><p>总结： 背景色1 / 对比2 / 不滥用颜色3 4 / 适当使用颜色色彩5 6 / 非数据部分不多加装饰7 / 尊重色盲用户8 / 避免使用光效9 </p></blockquote><h2 id="格式塔原理"><a href="#格式塔原理" class="headerlink" title="格式塔原理"></a>格式塔原理</h2><ol><li>接近性：物理上接近的物体属于同一群体</li><li>相似性：相似颜色、形状、大小或者方向的物体视为相关或从属同一群体</li><li>图形与背影：观众会将即使是不同形状的物体和背景自动构成图形 （Viewers will perceive an object and a surface even in shapes are grouped together）<br><img src="/images/blogs/dv&amp;d3/lesson4/figure_ground.png" alt></li><li>连续性：视觉倾向于寻找最平稳的路径并自然创造出连续性</li><li>封闭性：视觉会自动填充图形为可识别的形状</li><li>简单性：图像会被处理为简单的元素，而非复杂的形状。（Figures are seen as their simple elements instead of complicated shapes）<br><img src="/images/blogs/dv&amp;d3/lesson4/simplicity.png" alt></li></ol><blockquote><p>参考<br><a href="https://www.slideshare.net/luisaepv/the-gestalt-laws-of-perception" target="_blank" rel="noopener">认知的格式塔原理</a><br><a href="http://www.storytellingwithdata.com/book/" target="_blank" rel="noopener">Storytelling with Data: A Data Visualization Guide for Business Professionals</a><br><a href="http://graphicdesign.spokanefalls.edu/tutorials/process/gestaltprinciples/gestaltprinc.htm" target="_blank" rel="noopener">The Gestalt Principles</a></p></blockquote><h2 id="图表的有效性"><a href="#图表的有效性" class="headerlink" title="图表的有效性"></a>图表的有效性</h2><h3 id="Data-Ink-Ratio"><a href="#Data-Ink-Ratio" class="headerlink" title="Data-Ink Ratio"></a>Data-Ink Ratio</h3><p>Data-Ink Ratio = Ink used to describe data / ink used to describe everything else</p><h3 id="失真系数"><a href="#失真系数" class="headerlink" title="失真系数"></a>失真系数</h3><p>用于描述图表的完整性或图表展示数据的效果，通常期望在0.95~1.05之间。<br><img src="/images/blogs/dv&amp;d3/lesson4/liefactor.png" alt></p><h2 id="图形语法"><a href="#图形语法" class="headerlink" title="图形语法"></a>图形语法</h2><ul><li><a href="https://www.amazon.com/The-Grammar-Graphics-Statistics-Computing/dp/0387245448" target="_blank" rel="noopener">图形语法</a>  </li><li><a href="https://www.science-craft.com/2014/07/08/introducing-the-grammar-of-graphics-plotting-concept/" target="_blank" rel="noopener">Introducing the Grammar of Graphics Plotting Concept</a></li></ul><p>将数据或内容与形状分隔开.</p><h3 id="关注点分隔"><a href="#关注点分隔" class="headerlink" title="关注点分隔"></a>关注点分隔</h3><p>从数据的视觉呈现中分离数据的好处。以下为主要的几点：</p><ul><li>独立转换并展示数据</li><li>委派工作和责任<ul><li>工程师关注数据操纵</li><li>设计人员关注数据的视觉编码</li></ul></li><li>展示数据集的多个视觉表征<ul><li>不包括：气泡图和线条图呈现数据集的不同分面。</li></ul></li></ul><h3 id="常见元素"><a href="#常见元素" class="headerlink" title="常见元素"></a>常见元素</h3><p>当你想创建图表或图形时，从视觉上分解你希望实现的目的通常很有帮助。在前几段视频中，你看到了如何将图表提取到更为基础的视觉编码中。在地图示例中，你看到的面量图是地形和颜色的结合，而统计图是地形和尺寸的结合。在谈论可组合的元素时，最常见的就是：</p><ul><li>坐标系（笛卡尔与径向/极坐标系）</li><li>标尺（线性、对数等）</li><li>文本注释</li><li>形状（线条、圆圈等）</li><li>数据类型（分类、连续等）</li></ul><h3 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h3><p>当你将这些常见元素组合到一起时，你就能发现图形语法的迷人之处了。例如，你可以在笛卡尔空间中，将数据值映射到条形高度，从而创建条形图。你也可以在极坐标系中映射这些值（数据值对应到切片的径向度数），得到饼状图。</p><ul><li>分类数据 + 连续数据 x 笛卡尔坐标系 = 条形图</li><li>分类数据 + 连续数据 x 极坐标系 = 饼状图</li><li>连续数据 + 连续数据 x 笛卡尔坐标系 = 散点图</li></ul><p>你可以通过不同的方式组合这些常见元素，从而创建许多其他的图表。</p><h3 id="图形语法与D3"><a href="#图形语法与D3" class="headerlink" title="图形语法与D3"></a>图形语法与D3</h3><p><img src="/images/blogs/dv&amp;d3/lesson4/d3.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一节(Lesson 4)更多关注一些设计的概念和注意事项。&lt;br&gt;
    
    </summary>
    
    
      <category term="Data Visualization and D3.js" scheme="https://soundquiet.github.io/categories/Data-Visualization-and-D3-js/"/>
    
    
      <category term="data visualization" scheme="https://soundquiet.github.io/tags/data-visualization/"/>
    
      <category term="d3.js" scheme="https://soundquiet.github.io/tags/d3-js/"/>
    
  </entry>
  
  <entry>
    <title>Data Visualization and D3.js 笔记(2)</title>
    <link href="https://soundquiet.github.io/2018/09/29/Data-Visualization-and-D3-js-%E7%AC%94%E8%AE%B0-2/"/>
    <id>https://soundquiet.github.io/2018/09/29/Data-Visualization-and-D3-js-笔记-2/</id>
    <published>2018-09-29T08:37:24.000Z</published>
    <updated>2018-09-29T08:48:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>这一节介绍了一些D3的入门知识，比较琐碎，重点还是D3的练习<br>还有第一二节的问答题 </p><a id="more"></a><h1 id="Lesson-2-可视化和D3基础知识"><a href="#Lesson-2-可视化和D3基础知识" class="headerlink" title="Lesson 2 可视化和D3基础知识"></a>Lesson 2 可视化和D3基础知识</h1><h2 id="D3-新版本"><a href="#D3-新版本" class="headerlink" title="D3 新版本"></a>D3 新版本</h2><p>D3 v4中的每个符号都共享一个<strong>平面名称空间</strong>，而不像v3中是嵌套的。</p><table><thead><tr><th>v3</th><th>v4</th></tr></thead><tbody><tr><td>d3.scale.linear</td><td>d3.scaleLinear</td></tr><tr><td>d3.layout.treemap</td><td>d3.treemap</td></tr></tbody></table><h2 id="加载D3"><a href="#加载D3" class="headerlink" title="加载D3"></a>加载D3</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"&lt;d3.v3.min.js的地址&gt;"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="js文件的最小化和丑化"><a href="#js文件的最小化和丑化" class="headerlink" title="js文件的最小化和丑化"></a>js文件的最小化和丑化</h3><p><strong>最小化 Minify</strong> 去掉不必要的格式符、空白符等<br><strong>丑化 Uglify</strong> 缩短变量名称</p><p><strong>Often times the D3 script is aloso surfing a content delivery network (CDN) and this just gives you quick access to the script, so that way your client can download it and make it available for the application.</strong></p><h2 id="D3-入门"><a href="#D3-入门" class="headerlink" title="D3 入门"></a>D3 入门</h2><h3 id="文档选择器"><a href="#文档选择器" class="headerlink" title="文档选择器"></a>文档选择器</h3><ul><li>JavaScript<br>document.getElementById/ByName…()<br>jQuery可以让选择DOM节点十分容易<br>返回DOM元素</li><li>CSS选择器<br>document.querySelector(‘.类名’)<br>返回文档中匹配指定 CSS 选择器的一个元素<br>返回DOM元素</li><li>D3选择器<br>返回D3数组对象，可进行D3操作</li></ul><h3 id="类选择注意点"><a href="#类选择注意点" class="headerlink" title="类选择注意点"></a>类选择注意点</h3><ol><li>类名在一个页面上是不唯一的，而id是唯一的</li><li><p><strong>并列选择</strong>，可以选择同时具有某些类名的元素</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">class</span>=<span class="string">"classA classB"</span>&gt;</span> <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line"></span><br><span class="line">d3.select(".classA.classB")</span><br></pre></td></tr></table></figure></li><li><p><strong>嵌套选择</strong>，当目标元素没有类名、id时，可以通过选择父级元素间接选择，以空格隔开</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">"hi"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"..."</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line">d3.select("#hi img"). ...</span><br></pre></td></tr></table></figure></li></ol><h3 id="D3链语法"><a href="#D3链语法" class="headerlink" title="D3链语法"></a>D3链语法</h3><p>D3 finds and returns a selection and then pass it to the next function.    </p><p>使用D3可以添加、删除和改变DOM节点</p><h3 id="Scale"><a href="#Scale" class="headerlink" title="Scale"></a>Scale</h3><p><img src="/images/blogs/dv&amp;d3/lesson2/scale.png" alt></p><p>d3.scale.linear().domain([15, 90]).range([250, 0])</p><p><strong>注意</strong> 用图形来表示数值比较时，注意半径问题——圆性呈现的是所提供数值（半径）的平方级比较，要确保数据的真实性</p><h3 id="制作一个柱状图"><a href="#制作一个柱状图" class="headerlink" title="制作一个柱状图"></a>制作一个柱状图</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://d3js.org/d3.v3.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">.chart rect &#123;</span><br><span class="line">  fill: steelblue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.chart text &#123;</span><br><span class="line">  fill: white;</span><br><span class="line">  font: 10px sans-serif;</span><br><span class="line">  text-anchor: end;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">function draw(data) &#123;</span><br><span class="line">  var width = 420,</span><br><span class="line">  barHeight = 20;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // x变量的定义是range方法的调用，但是返回的是比例对象</span><br><span class="line">  // x是个比例，而不是范围。</span><br><span class="line">  var x = d3.scale.linear()</span><br><span class="line">    .range([0, width]);</span><br><span class="line"></span><br><span class="line">  var chart = d3.select(".chart")</span><br><span class="line">      .attr("width", width);</span><br><span class="line"></span><br><span class="line">  // x.domain无需赋值给新的变量，因为domain和range会改变比例对象的内部状态</span><br><span class="line">  // d3.max(array[,accessor])返回给定数组array中自然排序最大的值。非数字排序，即"20"&lt;"3"</span><br><span class="line">  // 如果制定了accessor参数，等同于计算最大值之前调用了array.map(accessor)方法，而非内置的Math.max</span><br><span class="line">  x.domain([0, d3.max(data, function(d) &#123; return d.value; &#125;)]);</span><br><span class="line"></span><br><span class="line">  chart.attr("height", barHeight * data.length);</span><br><span class="line"></span><br><span class="line">  var bar = chart.selectAll("g") // find every gourp tag</span><br><span class="line">      .data(data)</span><br><span class="line">      .enter() // 传回data调用的子集，代表的是页面上还没有放置的每个数据</span><br><span class="line">      .append("g")//为enter选择的每个点在图标上加入一个g元素</span><br><span class="line">      .attr("transform", function(d, i) &#123; return "translate(0," + i * barHeight + ")"; &#125;);</span><br><span class="line">  //此时的bar是一群g标签，仍非矩形</span><br><span class="line"></span><br><span class="line">  // add a rectangle for every data point</span><br><span class="line">  bar.append("rect") </span><br><span class="line">      .attr("width", function(d) &#123; return x(d.value); &#125;)</span><br><span class="line">      .attr("height", barHeight - 1);</span><br><span class="line"></span><br><span class="line">  bar.append("text")</span><br><span class="line">      .attr("x", function(d) &#123; return x(d.value) - 3; &#125;)</span><br><span class="line">      .attr("y", barHeight / 2)</span><br><span class="line">      .attr("dy", ".35em")</span><br><span class="line">      .text(function(d) &#123; return d.value; &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">svg</span> <span class="attr">class</span>=<span class="string">"chart"</span>&gt;</span><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  function type(d) &#123;</span><br><span class="line">    d.value = +d.value; // coerce to number</span><br><span class="line">    return d;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  d3.tsv("data.tsv", type, draw);</span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="阅读list"><a href="#阅读list" class="headerlink" title="阅读list"></a>阅读list</h2><ul><li><a href="https://bost.ocks.org/mike/bar/" target="_blank" rel="noopener">Let’s Make a Bar Chart</a>   </li><li>d3文档</li></ul><h1 id="Lesson-3-Exercise-for-Lesson-1-amp-2"><a href="#Lesson-3-Exercise-for-Lesson-1-amp-2" class="headerlink" title="Lesson 3 Exercise for Lesson 1 &amp; 2"></a>Lesson 3 Exercise for Lesson 1 &amp; 2</h1><p>Summary statistics can hide patterns and outliers in data sets which is why exploratory plots are helpful for “seeing” data.  —- True  </p><blockquote><p>Anscombe’s Quartet shows why this is so import</p></blockquote><hr><p>How does data visualization take advantage of human perception?</p><ol><li>Humans can process visual information in parallel (all at once) as opposed to taking in information serially, like when reading text word by word.</li><li>Human eye is excellent at indentifying differences in placement &amp; color</li></ol><p>[x] Visual encodings are chosen to be flashy and to grab the reader’s attention.<br>That’s <strong>wrong</strong> because the decision to pick up visual encodings shoule not be rely on being eye-catching.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一节介绍了一些D3的入门知识，比较琐碎，重点还是D3的练习&lt;br&gt;还有第一二节的问答题 &lt;/p&gt;
    
    </summary>
    
    
      <category term="Data Visualization and D3.js" scheme="https://soundquiet.github.io/categories/Data-Visualization-and-D3-js/"/>
    
    
      <category term="data visualization" scheme="https://soundquiet.github.io/tags/data-visualization/"/>
    
      <category term="d3.js" scheme="https://soundquiet.github.io/tags/d3-js/"/>
    
  </entry>
  
  <entry>
    <title>Fluent Python 读书笔记(2)</title>
    <link href="https://soundquiet.github.io/2018/09/29/Fluent-Python-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-2/"/>
    <id>https://soundquiet.github.io/2018/09/29/Fluent-Python-读书笔记-2/</id>
    <published>2018-09-29T08:35:12.000Z</published>
    <updated>2018-09-29T08:50:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>包括文本(第4章)和一等函数(第5章)<br><a id="more"></a></p><h1 id="Chap-4-文本和字节序列"><a href="#Chap-4-文本和字节序列" class="headerlink" title="Chap 4 文本和字节序列"></a>Chap 4 文本和字节序列</h1><h2 id="4-1-字符问题"><a href="#4-1-字符问题" class="headerlink" title="4.1 字符问题"></a>4.1 字符问题</h2><p>一个<strong>字符串</strong>是一个字符序列。<br>2015年，<strong>字符</strong>的最佳定义是Unicode字符。<br>Unicode标准将字符的标识和具体的字节表述做了明确区分：</p><ul><li>字符的标识，即<strong>码位</strong> 在Unicode标准中以4-6个十六进制数字表示，并且加前缀“U+”</li><li>字符的具体表述取决于所用的<strong>编码</strong>。编码是在码位和字符序列之间转换时使用的算法。</li></ul><p>把码位转为字节序列是<strong>编码</strong>， 反之是<strong>解码</strong>。</p><h2 id="4-2-字节概要"><a href="#4-2-字节概要" class="headerlink" title="4.2 字节概要"></a>4.2 字节概要</h2><p>Python 3引入不可变bytes类型，2.6添加可变bytearray类型<br>bytes或bytearray对象的各个元素是介于0-255（含）之间的整数。<br><strong>二进制序列的切片始终是同一类型的二进制序列</strong></p><p>各个字节的值会以三种不同的方式显示：</p><ul><li>可打印的ASCII范围内的字节（从空格到~），使用ASCII本身</li><li>制表符、换行符、回车符和\对应的字节，使用转义序列\t,\n,\t,\</li><li>其他字节的值，使用十六进制转义序列</li></ul><p>构建bytes和bytearray实例可以调用各自的构造方法，传入参数：</p><ul><li>一个str对象和一个encoding关键字参数</li><li>一个可迭代对象，提供0-255之间的数值</li><li>一个整数，使用空字节创建对应长度的二进制序列。（3.6删除）</li><li>一个实现了缓冲协议的对象，如bytes, bytearray, memoryview, array.array，此时把原对象中的字节序列复制到新建的二进制序列中</li></ul><h3 id="结构体和内存视图"><a href="#结构体和内存视图" class="headerlink" title="结构体和内存视图"></a>结构体和内存视图</h3><p>memoryview不是用于创建或存储字节序列的，而是共享内存，可以访问其他二进制序列、打包的数组和缓冲中的数据切片，而无需复制字节序列。他的切片是一个新的memoryview对象，而且不会复制字节序列。</p><h2 id="4-3-基本的编解码器"><a href="#4-3-基本的编解码器" class="headerlink" title="4.3 基本的编解码器"></a>4.3 基本的编解码器</h2><h2 id="4-4-了解编解码问题"><a href="#4-4-了解编解码问题" class="headerlink" title="4.4 了解编解码问题"></a>4.4 了解编解码问题</h2><h3 id="处理UnicodeEncodeError"><a href="#处理UnicodeEncodeError" class="headerlink" title="处理UnicodeEncodeError"></a>处理UnicodeEncodeError</h3><p>编码问题<br>把文本转换为字节序列时，如果目标编码中没有定义的某个字符，就会抛出<code>UnicodeEncodeError</code>。除非用errors参数传给编码方法或函数，对错误进行特殊处理。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">text.encode(<span class="string">'cp437'</span>, errors=<span class="string">'ignore|replace|xmlcharrefreplace'</span>)</span><br><span class="line"><span class="comment"># ignore 会跳过无法编码的字符</span></span><br><span class="line"><span class="comment"># replace 会用?替换无法编码的字符</span></span><br><span class="line"><span class="comment"># xmlcharrefreplace 将无法编码的字符替换成XML实体</span></span><br></pre></td></tr></table></figure></p><h3 id="处理UnicodeDecodeError"><a href="#处理UnicodeDecodeError" class="headerlink" title="处理UnicodeDecodeError"></a>处理UnicodeDecodeError</h3><p>不是每个字节都包含有效的ASCII字符，也不是每个字符序列都是有效的UTF8或16，在将二进制序列转换成文本时，假设是这两个编码中的一种，遇到无法转换的字节序列会抛出UnicodeDecodeError<br>而陈旧的8位编码，比如cp1252等能编码任何字节序列流而不抛出错误</p><h3 id="使用预期之外的编码加载模块时抛出的SyntaxError"><a href="#使用预期之外的编码加载模块时抛出的SyntaxError" class="headerlink" title="使用预期之外的编码加载模块时抛出的SyntaxError"></a>使用预期之外的编码加载模块时抛出的SyntaxError</h3><p>Python 3默认使用UTF-8编码源码，而2.5开始则默认使用ASCII<br>如果加载的.py模块中包含UTF8之外的数据，而且没有声明编码，会得到SyntaxError<br>可在文件顶部添coding注释：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># coding: cp1252</span><br></pre></td></tr></table></figure></p><h3 id="BOM的问题"><a href="#BOM的问题" class="headerlink" title="BOM的问题"></a>BOM的问题</h3><p>BOM是字节序标记，Unicode码点U+FEFF，放在UTF16文件的开头，如果字节序是FEFF则是大字节序，FFFE则是小字节序。<br>UTF8由于编码特性与字节序无关，所以不需要BOM。但是微软习惯在UTF8中使用BOM。  </p><p><strong>锟斤拷的问题</strong>：一些语言体系在转为Unicode时，有些字符不存在，Unicode规定以<code>U+FFFD</code>作为占位符表示这些字符，用UTF8编码为<code>EF BF BD</code>， 连续多个<code>EF BF BD</code>会被GB编码程序以两个字节一个汉字的形式编码，就会出现“锟斤拷”。 为了避免这个问题可以减少程序的编码转换。<br><em>参考 <a href="http://jimliu.net/2015/03/07/something-about-encoding-extra/" target="_blank" rel="noopener">http://jimliu.net/2015/03/07/something-about-encoding-extra/</a></em></p><h2 id="4-5-处理文本文件"><a href="#4-5-处理文本文件" class="headerlink" title="4.5 处理文本文件"></a>4.5 处理文本文件</h2><p>处理文本的最佳实践：</p><ol><li>解码输入的字节序列</li><li>只处理文本</li><li>编码输出的文本</li></ol><p>Python 3 内置的<code>open</code>函数会在读取文件时作必要的解码，以文本模式写入文件时还会做必要的编码，所以调用<code>my_file.read()</code>方法得到的以及传给<code>my_file.write(text)</code>方法都是字符串对象。  </p><h3 id="编码默认值"><a href="#编码默认值" class="headerlink" title="编码默认值"></a>编码默认值</h3><p>如果打开文件时没有指定encoding参数，默认值由<code>locale.getpreferredencoding()</code>提供，这个值也是重定向到文件的<code>sys.stdout/stdin/stderr</code>的默认编码。但是，用户的编号设置在不同系统中的设定方式不同，而且在某些系统中可能无法通过编程方式设置，因此这个函数返回的只是猜测的编码。<br>所以，<strong>不要依赖默认值！！！</strong></p><h2 id="4-6-为了正确比较而规范化Unicode字符串"><a href="#4-6-为了正确比较而规范化Unicode字符串" class="headerlink" title="4.6 为了正确比较而规范化Unicode字符串"></a>4.6 为了正确比较而规范化Unicode字符串</h2><p>Unicode有组合字符，字符串的比较会比较复杂。<br>比如，café有两种构成方式：</p><ol><li>café</li><li>cafe\u0301</li></ol><p>因为它们的码位不同，所以比较结果是不等同的。<br>U+0301是COMBINING ACUTE ACCENT, 加在e后得到é。 在Unicode标准中，’café’和’e\u0301’称为<strong>标准等价物</strong>(canonical equivalent)。Python判断的是码位序列，因此判为不等。  </p><p>这种问题的解决方式是：使用<code>unicodedata.normalize</code>函数提供的Unicode规范化。这个函数的第一个参数有四种选择：  </p><ol><li>NFC，Normalization Form C，使用最少的码位构成等价的字符串。<br>西方键盘通常能输出组合字符，因此用户输入的文本默认是NFC形式，但是还是在保存文本之前使用<code>normalize(&#39;NFC&#39;, text)</code>清洗文本。<br>使用NFC时，有些单字符会被规范为另一个单字符。比如电阻单位欧姆和希腊字母大写的欧米茄。二者在视觉上一样，但是比较时并不相等。</li><li><p>NFD，把组合字符分解成基字符和单独的组合字符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> unicodedata <span class="keyword">import</span> normalize</span><br><span class="line">s1 = <span class="string">'café'</span></span><br><span class="line">s2 = <span class="string">'cafe\u0301'</span></span><br><span class="line">print(len(normalize(<span class="string">'NFC'</span>, s1)), len(normalize(<span class="string">'NFC'</span>, s2)))</span><br><span class="line"><span class="comment"># 4, 4</span></span><br><span class="line">print(len(normalize(<span class="string">'NFD'</span>, s1)), len(normalize(<span class="string">'NFD'</span>, s2)))</span><br><span class="line"><span class="comment"># 5, 5</span></span><br><span class="line">print(normalize(<span class="string">'NFC'</span>, s1) == normalize(<span class="string">'NFC'</span>, s2))</span><br><span class="line"><span class="comment"># true</span></span><br><span class="line">print(normalize(<span class="string">'NFD'</span>, s1) == normalize(<span class="string">'NFD'</span>, s2))</span><br><span class="line"><span class="comment"># true</span></span><br></pre></td></tr></table></figure></li><li><p>NFKC, K表示“compatibility”，兼容性，是比较严格的规范化形式，对“兼容字符”有影响。<br>在NFKC和NFKD中，兼容字符会被替换为一个或多个“兼容分解字符”，可能会损失或曲解信息，但是可以为<strong>搜索和索引</strong>提供便利的中间表述。</p></li><li>NFKD</li></ol><h3 id="大小写折叠"><a href="#大小写折叠" class="headerlink" title="大小写折叠"></a>大小写折叠</h3><p>大小写折叠将所有文本变成小写，再做些其他转换。  </p><p>对于只包含latin1的字符的字符串s, <code>s.casefold()</code>和<code>s.lower()</code>一样，只有两个例外：</p><ol><li>微符号会变成小写希腊字母μ</li><li>德语ß会变成ss</li></ol><p>Python 3.4起<code>s.casefold()</code>和<code>s.lower()</code>不同结果的有116个码位，占Unicode字符的0.11%</p><h3 id="规范化文本匹配实用函数"><a href="#规范化文本匹配实用函数" class="headerlink" title="规范化文本匹配实用函数"></a>规范化文本匹配实用函数</h3><p>NFC和NFC可以合理比较Unicode字符串，对于大部分应用来说，NFC是最好的最规范化形式。<br>不区分大小写的应该使用<code>str.casefold()</code><br>处理多语言文本：</p><ol><li>nfc_equal<br>大小写敏感</li><li>fold_equal<br>存在大小写折叠的问题</li></ol><h2 id="4-7-Unicode文本排序"><a href="#4-7-Unicode文本排序" class="headerlink" title="4.7 Unicode文本排序"></a>4.7 Unicode文本排序</h2><p>不同地区采用的排序规则有所不同。  </p><p>在Python， 非ASCII文本的排序标准是使用<code>locale.strxfrm</code>函数，这个函数会把字符串转换为适合所在区域进行比较的形式。<br>在使用<code>locale.strxfrm</code>之前，必须先为应用设定合适的区域设置,<code>locale.setlocale(LC_COLLATE, &lt;YOUR_LOCALE&gt;)</code>(先import locale)</p><p>区域设置是全局的！因此不推荐在库中调用<code>setlocale</code>，应用或框架应在进程启动时设定区域设置，而且此后不要再修改。</p><h3 id="使用Unicode排序算法排序"><a href="#使用Unicode排序算法排序" class="headerlink" title="使用Unicode排序算法排序"></a>使用Unicode排序算法排序</h3><p>因为上述方法存在一些注意事项，James Tauber开发了Unicode排序算法，Unicode Collation Algorithm。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyuca</span><br><span class="line">coll = pyuca.Collator()</span><br><span class="line">fruits = [ ... ]</span><br><span class="line">sorted_fruits = sorted(fruits, key=coll.sort_key)</span><br></pre></td></tr></table></figure></p><p>PyUCA默认使用项目自带的allkeys.txt，没有考虑区域设置。</p><h2 id="4-8-Unicode数据库"><a href="#4-8-Unicode数据库" class="headerlink" title="4.8 Unicode数据库"></a>4.8 Unicode数据库</h2><p>Unicode标准提供了一个完整的数据库，不仅包括码位与字符名称之间的映射，还有各个字符的元数据，以及字符之间的关系</p><h2 id="4-9-支持字符串和字符序列的双模式API"><a href="#4-9-支持字符串和字符序列的双模式API" class="headerlink" title="4.9 支持字符串和字符序列的双模式API"></a>4.9 支持字符串和字符序列的双模式API</h2><h3 id="正则表达式中的字符串和字符序列"><a href="#正则表达式中的字符串和字符序列" class="headerlink" title="正则表达式中的字符串和字符序列"></a>正则表达式中的字符串和字符序列</h3><p>如果使用字符序列构建正则表达式，\d和\s等模式只能匹配ASCII字符；<br>如果使用字符串模式，就能匹配ASCII之外的Unicode数字或字母</p><h3 id="os函数中的字符串和字符序列"><a href="#os函数中的字符串和字符序列" class="headerlink" title="os函数中的字符串和字符序列"></a>os函数中的字符串和字符序列</h3><p>os模块中的所有函数、文件名和路径名参数既能使用字符串，也能使用字节序列。  </p><blockquote><p> 字符串好多琐碎的知识啊<em>(:з)∠)</em></p></blockquote><h1 id="Chap-5-一等函数"><a href="#Chap-5-一等函数" class="headerlink" title="Chap 5 一等函数"></a>Chap 5 一等函数</h1><p><strong>一等对象</strong>满足：</p><ol><li>在运行时创建</li><li>能赋值给变量或数据结构中的元素</li><li>能作为参数传给函数</li><li>能作为函数的返回结果</li></ol><p>Python中，整数、字符串、字典都是一等对象。 函数也是。</p><h2 id="5-1-把函数视作对象"><a href="#5-1-把函数视作对象" class="headerlink" title="5.1 把函数视作对象"></a>5.1 把函数视作对象</h2><h2 id="5-2-高阶函数"><a href="#5-2-高阶函数" class="headerlink" title="5.2 高阶函数"></a>5.2 高阶函数</h2><p><strong>接收函数为参数</strong>，或者<strong>把函数作为结果返回</strong>的函数是<strong>高阶函数</strong>。<br>常见的有<code>map</code>, 内置函数<code>sorted</code>也是，可选的key参数用于提供一个函数,任何单函数参数都能作为key的值。</p><p>在函数式编程范式里，最为人熟知的高阶函数有<code>map</code>, <code>filter</code>, <code>reduce</code>和<code>apply</code>。<br><code>apply</code>在Python 3 中移除了。  </p><h3 id="map-filter和reduce的替代品"><a href="#map-filter和reduce的替代品" class="headerlink" title="map, filter和reduce的替代品"></a>map, filter和reduce的替代品</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">list(map(factorial, range(<span class="number">6</span>)))</span><br><span class="line"><span class="comment"># 等同于</span></span><br><span class="line">[factorial(n) <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">6</span>)]</span><br><span class="line"></span><br><span class="line">list(map(factorial, filter(<span class="keyword">lambda</span> n : n % <span class="number">2</span>, range(<span class="number">6</span>))))</span><br><span class="line"><span class="comment"># 等同于</span></span><br><span class="line">[factorial(n) <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">6</span>) <span class="keyword">if</span> n % <span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>在Python 3 中，<code>map</code>和<code>filter</code>返回生成器，所以替代品是生成器表达式。 在Python 2 中返回的是列表，所以替代品是列表推导。</p><p>Python 2 中<code>reduce</code>是内置函数， Python 3 中放入了<code>functools</code>模块中了。  常用于求和，最好使用内置的<code>sum</code>函数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> add</span><br><span class="line">reduce(add, range(<span class="number">100</span>))</span><br><span class="line"><span class="comment"># 等同于</span></span><br><span class="line">sum(range(<span class="number">100</span>))</span><br></pre></td></tr></table></figure></p><p><code>sum</code>和<code>reduce</code>的通用思想是把某个操作连续应用到序列的元素上，累计之前的结果，把系列值<strong>归约</strong>成一个值。还有以下内置归约函数：</p><ul><li>all(iterable) 如果每个元素都是真值，返回True， all([])返回True</li><li>any(iterable) 只要元素中有真值，返回True， any([])返回True</li></ul><h2 id="5-3-匿名函数"><a href="#5-3-匿名函数" class="headerlink" title="5.3 匿名函数"></a>5.3 匿名函数</h2><p><code>lambda</code>关键字在Python表达式里创建匿名函数</p><p>但是，lambda函数的定义体只能使用纯表达式： 不能赋值、不能使用while和try等Python语句。  </p><p>在参数列表中最适合使用匿名函数。<br>除了作为参数传给高阶函数外，Python很少使用匿名函数。</p><p>lambda句法只是语法糖（指计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。通常来说使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会。）和def语句一样，lambda表达式会创建函数对象。</p><h2 id="5-4-可调用对象"><a href="#5-4-可调用对象" class="headerlink" title="5.4 可调用对象"></a>5.4 可调用对象</h2><p>判断对象能否被调用，可以使用内置的<code>callable()</code>函数。 Python数据模型文档列出了7中可调用对象：</p><ol><li>用户定义的函数<br>使用def语句或lambda表达式创建</li><li>内置函数<br>使用C语言(CPython)实现的函数，如<code>len</code>或<code>time.strftime</code></li><li>内置方法<br>使用C语言实现的方法，如<code>dict.get</code></li><li>方法<br>在类的定义体中定义的函数</li><li>类<br>调用类时会允许类的<code>__new__</code>方法创建一个实例，然后运行<code>__init__</code>方法，初始化实例，最后把实例返回给调用方。</li><li>类的实例<br>如果类定义了<code>__call__</code>方法，它的实例可以作为函数调用</li><li>生成器函数<br>使用<code>yield</code>关键字的函数或方法。调用生成器函数返回的是生成器对象</li></ol><h2 id="5-5-用户定义的可调用类型"><a href="#5-5-用户定义的可调用类型" class="headerlink" title="5.5 用户定义的可调用类型"></a>5.5 用户定义的可调用类型</h2><p>任何Python对象都可以表现得像函数，只需实现实例方法<code>__call__</code></p><p>实现<code>__call__</code>方法的类是创建函数类对象的简便方法，此时必须在内部维护一个状态。让他在调用之间可用。<br>装饰器就是这样，它必须是函数，而且有时要在多次调用之间记住某些事。<br>创建保有内部状态的函数，还可以使用闭包。</p><h2 id="5-6-函数内省"><a href="#5-6-函数内省" class="headerlink" title="5.6 函数内省"></a>5.6 函数内省</h2><p>内省是指在运行时确定对象类型的能力。</p><p>用<code>dir()</code>函数可以查看某函数具有的属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir(factorial)</span><br></pre></td></tr></table></figure></p><p>返回的属性大多数是Python对象共有的，可以通过求差集得到用户定义函数特有的属性。  </p><p><strong>用户定义的函数的属性</strong><br>| 名称 | 类型 | 说明 |<br>| —– | —– | —-|<br>| <strong>annotations</strong> | dict | 参数和返回值的注解 |<br>| <strong>call</strong> | method-wrapper | 实现()运算符，即可调用对象协议 |<br>| <strong>closure</strong> | tuple | 函数闭包，即自由变量的绑定 |<br>| <strong>code</strong> | code | 编译成字节码的函数元数据和函数定义体 |<br>| <strong>defaults</strong> | tuple | 形式参数的默认值 |<br>| <strong>get</strong> | method-wrapper | 实现只读描述符协议 |<br>| <strong>globals</strong> | dict | 函数所在模块中的全局变量 |<br>| <strong>kwdefaults</strong> | dict | 仅限关键字形式参数的默认值 |<br>| <strong>name</strong> | str | 函数名称 |<br>| <strong>qualname</strong> | str | 函数的限定名称 |</p><h2 id="5-7-从定位参数到仅限关键字参数"><a href="#5-7-从定位参数到仅限关键字参数" class="headerlink" title="5.7 从定位参数到仅限关键字参数"></a>5.7 从定位参数到仅限关键字参数</h2><p><strong>仅限关键字</strong> 是Python 3新特性，指参数只能通过关键字参数制定，一定不会捕获未命名的定位参数，它们在函数定义时放在前面有<em>的参数后面。<br>调用函数是使用 </em> 和 *<em> 展开可迭代对象，映射到单个参数。  </em>捕获该位置起的任意个参数。</p><p>仅限关键字参数不一定要有默认值。</p><h2 id="5-10-函数式编程"><a href="#5-10-函数式编程" class="headerlink" title="5.10 函数式编程"></a>5.10 函数式编程</h2><h3 id="operator模块"><a href="#operator模块" class="headerlink" title="operator模块"></a>operator模块</h3><p>operator模块为多个算数运算符提供了对应的函数。如<code>add</code>, <code>mul</code>等。<br><code>itemgetter</code>可以用来根据元素的某个字段给元组列表排序, 如果传入多个参数可返回提取的值构成的元组。<br><code>attrgetter</code>创建的函数根据名称提取对象的属性。</p><h3 id="使用functools-partial-冻结参数"><a href="#使用functools-partial-冻结参数" class="headerlink" title="使用functools.partial 冻结参数"></a>使用functools.partial 冻结参数</h3><p><code>functools.partial</code> 用于部分应用于一个函数，基于一个函数创建新的可调用对象，把某些参数固定。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;包括文本(第4章)和一等函数(第5章)&lt;br&gt;
    
    </summary>
    
    
      <category term="Fluent Python" scheme="https://soundquiet.github.io/categories/Fluent-Python/"/>
    
    
      <category term="Python" scheme="https://soundquiet.github.io/tags/Python/"/>
    
      <category term="读书笔记" scheme="https://soundquiet.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Data Visualization and D3.js 笔记(1)</title>
    <link href="https://soundquiet.github.io/2018/09/23/Data-Visualization-and-D3-js-%E7%AC%94%E8%AE%B0-1/"/>
    <id>https://soundquiet.github.io/2018/09/23/Data-Visualization-and-D3-js-笔记-1/</id>
    <published>2018-09-23T14:23:50.000Z</published>
    <updated>2018-09-29T08:40:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>课程地址: <a href="https://classroom.udacity.com/courses/ud507" target="_blank" rel="noopener">https://classroom.udacity.com/courses/ud507</a></p><h1 id="Lesson-1-可视化基础"><a href="#Lesson-1-可视化基础" class="headerlink" title="Lesson 1 可视化基础"></a>Lesson 1 可视化基础</h1><h2 id="什么是数据可视化？"><a href="#什么是数据可视化？" class="headerlink" title="什么是数据可视化？"></a>什么是数据可视化？</h2><ul><li>高效传达一个故事/概念，探索数据的pattern</li><li>通过颜色、尺寸、形式在视觉上表示基础数据和storytelling，然后得到一些发现</li></ul><p>数据可视化是一种从值到图像的映射，将结构化的数据信息转化为更易理解的视觉图像。<br><img src="/images/blogs/dv&amp;d3/lesson1/chart1.png" alt></p><a id="more"></a><h2 id="什么是好的数据可视化？-by-Cole-Nussbaumer"><a href="#什么是好的数据可视化？-by-Cole-Nussbaumer" class="headerlink" title="什么是好的数据可视化？[by Cole Nussbaumer]"></a>什么是好的数据可视化？[by Cole Nussbaumer]</h2><ol><li>对内容有透彻的理解，知道谁是观众、他们想得到什么？</li><li>数据展示，选择恰当的图像类型</li><li>排除无效信息，删除不会为图像增加价值的内容。降低认知负担，突出数据</li><li>通过颜色、尺寸、布局等元素吸引观众注意力，让他们知道哪里是重点</li><li>故事叙述。好的数据可视化会让本身成为故事或叙述的关键点</li></ol><h2 id="数据科学与数据可视化"><a href="#数据科学与数据可视化" class="headerlink" title="数据科学与数据可视化"></a>数据科学与数据可视化</h2><p><img src="/images/blogs/dv&amp;d3/lesson1/chart2.png" alt><br>(<em>by Ben Fry</em>)<br>这是一个非线性迭代，在过程中会不断回溯前一步骤，或从新数据得到新结果进行合并。  </p><h3 id="EDA-vs-Data-Visualization"><a href="#EDA-vs-Data-Visualization" class="headerlink" title="EDA vs. Data Visualization"></a>EDA vs. Data Visualization</h3><p>EDA, Exploratory Data Analysis, is whatever happened between you and your data when you are not trying to proof anything to anyone. But Data Visualization cares about it.<br><img src="/images/blogs/dv&amp;d3/lesson1/chart3.png" alt></p><h3 id="Amscombe-四重奏"><a href="#Amscombe-四重奏" class="headerlink" title="Amscombe 四重奏"></a>Amscombe 四重奏</h3><p>Anscombe’s quartet是指四组基本统计特征（均值、方差、相关系数、最优拟合线）一致的数据，由他们绘制出来的图形截然不同。<br>说明<strong>分析数据前先绘制图表的重要性，以及离群值对统计的影响</strong>。  </p><h2 id="Data-amp-amp-Data-Types"><a href="#Data-amp-amp-Data-Types" class="headerlink" title="Data &amp;&amp; Data Types"></a>Data &amp;&amp; Data Types</h2><ul><li>值数据 Quantitative Data<ul><li>离散 </li><li>连续</li></ul></li><li>分类数据 Categorical Data (表示特性，可以用数值表示，但是没有数学意义)<ul><li>定类数据 Nominal<ul><li>对数据进行标注和分类的一种方法</li></ul></li><li>有序数据 Ordinal</li></ul></li><li>时序数据 Time Series Data<ul><li>经过长时间重复观测得到的数据集合</li></ul></li></ul><h2 id="Visual-Encoding"><a href="#Visual-Encoding" class="headerlink" title="Visual Encoding"></a>Visual Encoding</h2><p>Visual Encoding is mapping data to display elements.</p><ol><li>Position<br> 平面内可对x和y两个变量进行编码<br> <strong>人眼对三维很难迅速感知</strong></li><li>Retinal Variables 视网膜变量<ul><li>For Ordered Data<ul><li>size</li><li>orientation</li><li>color saturation</li></ul></li><li>For Nominal Data<ul><li>color hue</li><li>shape</li><li>texture</li></ul></li></ul></li><li>Animation<br> not a Visual Encoding, but encodes some information<ul><li>time 用帧来代表时间</li></ul></li></ol><h3 id="Rankings-of-Visual-Encoding"><a href="#Rankings-of-Visual-Encoding" class="headerlink" title="Rankings of Visual Encoding"></a>Rankings of Visual Encoding</h3><p><img src="/images/blogs/dv&amp;d3/lesson1/chart4.png" alt></p><h2 id="D3-js"><a href="#D3-js" class="headerlink" title="D3.js"></a>D3.js</h2><p><img src="/images/blogs/dv&amp;d3/lesson1/chart5.png" alt></p><p>D3: Data Driven Document  </p><ul><li>Data: csv / json</li><li>Driven: 将csv / json 数据与SVG元素结合 (DOM)</li><li>Document: HTML, CSS, JS, SVG</li></ul><h3 id="DOM-与-HTML"><a href="#DOM-与-HTML" class="headerlink" title="DOM 与 HTML"></a>DOM 与 HTML</h3><p>浏览器存储两种Web页面/视图</p><ul><li><p>从服务器返回的初始源  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">svg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>解析的DOM对象</p><ul><li>DOM 是一个规范，为HTML和XML文档规定了常见的编程接口</li><li>在页面被加载的时候逐步解析</li><li>通过JavaScript API访问</li></ul></li></ul><h3 id="将HTML转为DOM"><a href="#将HTML转为DOM" class="headerlink" title="将HTML转为DOM"></a>将HTML转为DOM</h3><ol><li>用户发出访问某一URL的请求</li><li>浏览器向服务器发送请求</li><li>浏览器收到服务器响应，即HTML</li><li>浏览器开始处理HTML文件</li><li>遇到一个标记，如<code>&lt;html&gt;</code>，浏览器会发出一个token，<code>startTag: html</code> <code>startTag:head</code> <code>meta</code> <code>link</code></li><li>同时会消耗这些token， 生成节点对象，并建立联系</li><li>DOM树被生成  </li></ol><p><img src="/images/blogs/dv&amp;d3/lesson1/chart6.png" alt></p><h2 id="有趣的图表们"><a href="#有趣的图表们" class="headerlink" title="有趣的图表们"></a>有趣的图表们</h2><h3 id="斜率图-Slope-Graph"><a href="#斜率图-Slope-Graph" class="headerlink" title="斜率图 Slope Graph"></a>斜率图 Slope Graph</h3><p>用斜率代表方向和变化量，可以进行group之间的比较</p><h3 id="小多组图-Small-Multiples"><a href="#小多组图-Small-Multiples" class="headerlink" title="小多组图 Small Multiples"></a>小多组图 Small Multiples</h3><p>利用相同的布局，可以进行</p><ul><li>数据</li><li>数据组</li></ul><p>之间的比较</p><h3 id="一些链接"><a href="#一些链接" class="headerlink" title="一些链接"></a>一些链接</h3><ul><li><a href="https://charts.animateddata.co.uk/uktemperaturelines/" target="_blank" rel="noopener">https://charts.animateddata.co.uk/uktemperaturelines/</a>  </li><li><a href="http://www.storytellingwithdata.com/blog/2014/03/more-on-slopegraphs" target="_blank" rel="noopener">http://www.storytellingwithdata.com/blog/2014/03/more-on-slopegraphs</a>  </li><li><a href="https://www.youtube.com/watch?v=jbkSRLYSojo" target="_blank" rel="noopener">https://www.youtube.com/watch?v=jbkSRLYSojo</a></li><li><a href="https://www.targetprocess.com/articles/visual-encoding/" target="_blank" rel="noopener">https://www.targetprocess.com/articles/visual-encoding/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;课程地址: &lt;a href=&quot;https://classroom.udacity.com/courses/ud507&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://classroom.udacity.com/courses/ud507&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;Lesson-1-可视化基础&quot;&gt;&lt;a href=&quot;#Lesson-1-可视化基础&quot; class=&quot;headerlink&quot; title=&quot;Lesson 1 可视化基础&quot;&gt;&lt;/a&gt;Lesson 1 可视化基础&lt;/h1&gt;&lt;h2 id=&quot;什么是数据可视化？&quot;&gt;&lt;a href=&quot;#什么是数据可视化？&quot; class=&quot;headerlink&quot; title=&quot;什么是数据可视化？&quot;&gt;&lt;/a&gt;什么是数据可视化？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;高效传达一个故事/概念，探索数据的pattern&lt;/li&gt;
&lt;li&gt;通过颜色、尺寸、形式在视觉上表示基础数据和storytelling，然后得到一些发现&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数据可视化是一种从值到图像的映射，将结构化的数据信息转化为更易理解的视觉图像。&lt;br&gt;&lt;img src=&quot;/images/blogs/dv&amp;amp;d3/lesson1/chart1.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Data Visualization and D3.js" scheme="https://soundquiet.github.io/categories/Data-Visualization-and-D3-js/"/>
    
    
      <category term="data visualization" scheme="https://soundquiet.github.io/tags/data-visualization/"/>
    
      <category term="d3.js" scheme="https://soundquiet.github.io/tags/d3-js/"/>
    
  </entry>
  
  <entry>
    <title>Fluent Python 读书笔记 (1)</title>
    <link href="https://soundquiet.github.io/2018/09/23/Fluent-Python-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-1/"/>
    <id>https://soundquiet.github.io/2018/09/23/Fluent-Python-读书笔记-1/</id>
    <published>2018-09-23T13:51:58.000Z</published>
    <updated>2018-09-23T14:22:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chap-2-序列构成的数组"><a href="#Chap-2-序列构成的数组" class="headerlink" title="Chap 2 序列构成的数组"></a>Chap 2 序列构成的数组</h1><h2 id="2-1-内置序列类型"><a href="#2-1-内置序列类型" class="headerlink" title="2.1 内置序列类型"></a>2.1 内置序列类型</h2><ul><li><strong>容器序列</strong> 存放的是所包含的任意类型的对象的引用。list, tuple, collections.deque等</li><li><strong>扁平序列</strong> 存放的是值，是一段连续的内存空间，更为紧凑，但只能存放字符、字节和数值这种基础类型。str, bytes, bytearray, memoryview, array.array等  </li></ul><p>或者根据能否被修改来分类：</p><ul><li><strong>可变序列</strong> list, bytearray, array.array, collections.deque和memoryview。</li><li><strong>不可变序列</strong> tuple, str, bytes<a id="more"></a><h2 id="2-2-列表推导和生成器表达式"><a href="#2-2-列表推导和生成器表达式" class="headerlink" title="2.2 列表推导和生成器表达式"></a>2.2 列表推导和生成器表达式</h2><h3 id="列表推导-list-comprehension"><a href="#列表推导-list-comprehension" class="headerlink" title="列表推导 list comprehension"></a>列表推导 list comprehension</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">codes = [ord(symbol) <span class="keyword">for</span> symbol <span class="keyword">in</span> symbols]</span><br></pre></td></tr></table></figure></li></ul><p>通常的原则是，只用列表推导来生成新的列表。<br>Python 3之后列表推导不出现变量泄露。  </p><ul><li>注：Python会忽略代码里[]、{}和()中的换行。 </li></ul><p><strong>列表推导与笛卡儿积</strong><br>用列表推导可以生成两个或两个以上的可迭代类型的笛卡儿积，笛卡儿积是一个列表，列表中的元素为输入的可迭代元素构成的元组。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">colors = [<span class="string">'black'</span>, <span class="string">'white'</span>]</span><br><span class="line">sizes = [<span class="string">'S'</span>, <span class="string">'M'</span>, <span class="string">'L'</span>]</span><br><span class="line"><span class="comment"># 先以color排序</span></span><br><span class="line">tshirts = [(color, size) <span class="keyword">for</span> color <span class="keyword">in</span> colors <span class="keyword">for</span> size <span class="keyword">in</span> sizes]</span><br><span class="line"><span class="comment"># 先以size排序</span></span><br><span class="line">tshirts = [(color, size) <span class="keyword">for</span> size <span class="keyword">in</span> sizes <span class="keyword">for</span> color <span class="keyword">in</span> colors]</span><br></pre></td></tr></table></figure></p><h3 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h3><p>生成器表达式可以逐个产出元素，而不是先建立一个完整的列表。语法跟列表推导差不多，将[]换乘()。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">colors = [<span class="string">'black'</span>, <span class="string">'white'</span>]</span><br><span class="line">sizes = [<span class="string">'S'</span>, <span class="string">'M'</span>, <span class="string">'L'</span>]</span><br><span class="line"><span class="keyword">for</span> tshirt <span class="keyword">in</span> (<span class="string">'%s %s'</span> % (c, s) <span class="keyword">for</span> c <span class="keyword">in</span> colors <span class="keyword">for</span> s <span class="keyword">in</span> sizes):</span><br><span class="line">    print(tshirt)</span><br></pre></td></tr></table></figure></p><p>与列表推导不同，使用生成器表达式后，内存里不会留下一个有6个组合的列表，因为<strong>生成器表达式会在每次for循环运行时才生成一个组合</strong>。</p><h2 id="2-3-元组"><a href="#2-3-元组" class="headerlink" title="2.3 元组"></a>2.3 元组</h2><p>元素是对数据的记录，它的每个元素都存放了记录中一个字段的数据，外加这个字段的位置。 <strong>元组不仅仅是不可变的列表</strong></p><h3 id="元组拆包"><a href="#元组拆包" class="headerlink" title="元组拆包"></a>元组拆包</h3><p>平行赋值<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">coordinates = (<span class="number">22</span>, <span class="number">-118</span>)</span><br><span class="line">latitude, longitude = coordinates</span><br></pre></td></tr></table></figure></p><p>用*运算符把一个可迭代对象拆开作为函数的参数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="number">20</span>, <span class="number">8</span>)</span><br><span class="line">quotient, remainder = divmod(*t)</span><br></pre></td></tr></table></figure></p><p>如果只对元组中部分数据感兴趣，可以使用<code>_</code>占位符。<br>还可以使用<code>*</code>来处理剩下的元素, 以<code>*args</code>来获取不确定数量的参数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a, b, *rest = range(<span class="number">5</span>)</span><br><span class="line">print(a, b, rest)</span><br><span class="line"><span class="comment">#(0, 1, [2, 3, 4])</span></span><br><span class="line">head, a, b = range(<span class="number">5</span>)</span><br><span class="line"><span class="comment">#([0, 1, 2], 3, 4)</span></span><br></pre></td></tr></table></figure></p><h3 id="具名元组"><a href="#具名元组" class="headerlink" title="具名元组"></a>具名元组</h3><p><code>collections.namedtuple</code>可以用来构建一个带字段名的元组和一个有名字的类。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line">City = namedtuple(<span class="string">'City'</span>, <span class="string">'name country population coordinates'</span>)</span><br><span class="line"><span class="comment"># 具名元组的创建需要两个参数，一个是类名，另一个是类名各个字段的名称</span></span><br><span class="line">tokyo = City(<span class="string">'Tokyo'</span>, <span class="string">'JP'</span>, <span class="number">36.933</span>, (<span class="number">35</span>, <span class="number">139</span>))</span><br><span class="line"><span class="comment"># 以一串参数的形式将数据传入构造函数里，而元组的构造函数tuple()只能接受单一的可迭代对象</span></span><br><span class="line"><span class="comment"># tokyo.population 可以直接访问字段信息</span></span><br></pre></td></tr></table></figure></p><p>具名元组的常用属性有：</p><ul><li>_fields 包含这个类所有字段的元组</li><li>类方法 _make(iterable) 接受一个可迭代对象来生成这个类的实例，作用和 City(*data_tuple) 相同</li><li>实例方法 _asdict() 将具名元组以collections.OrderedDict的形式返回</li></ul><h2 id="2-4-切片"><a href="#2-4-切片" class="headerlink" title="2.4 切片"></a>2.4 切片</h2><p><strong>切片和区间都会忽略最后一个元素</strong></p><h3 id="对对象进行切片"><a href="#对对象进行切片" class="headerlink" title="对对象进行切片"></a>对对象进行切片</h3><p><code>s[a:b:c]</code>表示在a和b之间以c为间隔取值。c为负值表示反向取值。这种用法只能作为索引或者下标在[]之间返回一个切片对象。<br>Python会调用<code>s.__getitem__(slice(start, stop, step))</code>.</p><h3 id="多维切片和省略"><a href="#多维切片和省略" class="headerlink" title="多维切片和省略"></a>多维切片和省略</h3><p>[]运算符还可以是用以逗号分开的多个索引或者切片。比如numpy中numpy.ndarray就可以用<code>a[i,j]</code>或者<code>a[m:n, i:j]</code>的方式来获取。对象的特殊方法<code>__getitem__</code>和<code>__setitem__</code>需要以元组的形式来接收<code>a[i, j]</code>中的索引.<br><strong>省略</strong>是<strong>三个英文句号</strong><code>...</code>。如果x是四维数组，<code>x[i, ...]</code>就是<code>x[i, :, :, :]</code></p><h3 id="给切片赋值"><a href="#给切片赋值" class="headerlink" title="给切片赋值"></a>给切片赋值</h3><p>如果把切片放在赋值语句的左边，或者将他作为<code>del</code>操作的对象，可以对序列进行<strong>嫁接、切除或者就地修改</strong>。</p><h2 id="2-5-对序列进行-和"><a href="#2-5-对序列进行-和" class="headerlink" title="2.5 对序列进行+和*"></a>2.5 对序列进行+和*</h2><p><code>+</code>号两侧的序列由相同类型的数据所构成，不会对原序列进行修改， 而是新建一个类来作为拼接的结果。<br><code>*</code>号将序列复制几份然后拼接起来，同样不就地修改。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_list = [[<span class="string">'_'</span>]] * <span class="number">3</span></span><br><span class="line"><span class="comment"># 包含的3个元素是对同一个列表的引用</span></span><br></pre></td></tr></table></figure></p><p>应该为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">board = [[<span class="string">'_'</span>] * <span class="number">3</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>)] <span class="comment"># correct</span></span><br></pre></td></tr></table></figure></p><h2 id="2-6-序列的增量赋值"><a href="#2-6-序列的增量赋值" class="headerlink" title="2.6 序列的增量赋值"></a>2.6 序列的增量赋值</h2><p><code>+=</code>和<code>*=</code>的表现取决于他们第一个操作对象。<br><code>+=</code>的特殊方法是<code>__iadd__</code>，但是如果一个类没有实现这个方法的话，会退一步调用<code>__add__</code>, 先计算a+b, 得到一个新的对象， 然后赋值给a。<br>所以对于不可变序列进行重复拼接操作效率会很低。</p><h2 id="2-7-list-sort方法和内置函数sorted"><a href="#2-7-list-sort方法和内置函数sorted" class="headerlink" title="2.7 list.sort方法和内置函数sorted"></a>2.7 list.sort方法和内置函数sorted</h2><p><code>list.sort</code>会就地排序，这方法的返回值是None。（如果一个函数或者方法对对象进行的是就地改动，那么返回值就为None）<br>而<code>sorted</code>会返回一个新建的列表，它可以接收任何形式的可迭代对象，包括不可变序列和生成器。<br><code>list.sort</code>和 <code>sorted</code>都有两个参数：</p><ul><li>reverse 如果为true，为降序输出。默认值为false</li><li>key 会作用在每个元素上，所产生的结果是算法依赖的对比关键字。比如key=str.lower会实现忽略大小写的排序， key=len会进行字符串长度的排序。<h2 id="2-8-用bisect来管理已排序的序列。"><a href="#2-8-用bisect来管理已排序的序列。" class="headerlink" title="2.8 用bisect来管理已排序的序列。"></a>2.8 用bisect来管理已排序的序列。</h2>bisect模块包含<code>bisect</code>和<code>insort</code>两个主要函数，都是利用二分查找算法来在有序序列中查找或插入元素。<h3 id="用bisect来搜索"><a href="#用bisect来搜索" class="headerlink" title="用bisect来搜索"></a>用bisect来搜索</h3><code>bisect(haystack, needle)</code>表示在 haystack 里搜索 needle 的位置，该位置满足的条件是：把 needle 插入后还能保持升序。<br>可以先用<code>bisect(haystack, needle)</code>查找index，然后用<code>haystack.insert(index, neddle)</code>来插入新值。 但是<code>insort</code>比这个方法更快。   <h3 id="用bisect-insort插入新元素"><a href="#用bisect-insort插入新元素" class="headerlink" title="用bisect.insort插入新元素"></a>用bisect.insort插入新元素</h3><code>insort(seq, item)</code>将 item 插入 seq 中，并且保持 seq 的升序。</li></ul><h2 id="2-9-数组"><a href="#2-9-数组" class="headerlink" title="2.9 数组"></a>2.9 数组</h2><p>如果要存放的是1000万个浮点数时，array 的效率比列表高得多，因为它背后存的并不是 float 对象，而是数字的机器翻译。<br>Python 创建数组需要类型码，用于表示在底层的 C 语言应该存放怎样的数据类型。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> array <span class="keyword">import</span> array</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> random</span><br><span class="line">floats = array(<span class="string">'d'</span>, (random() <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>**<span class="number">7</span>)))</span><br></pre></td></tr></table></figure></p><h3 id="内存视图"><a href="#内存视图" class="headerlink" title="内存视图"></a>内存视图</h3><p><code>memoryview</code> 是一个内置类，让用户在不复制内容的情况下操作一个数组的不同切片。</p><h3 id="双向队列和其他形式的队列"><a href="#双向队列和其他形式的队列" class="headerlink" title="双向队列和其他形式的队列"></a>双向队列和其他形式的队列</h3><p>利用<code>append</code>和<code>pop</code>方法，可以将列表当成栈或队列来使用，但是删除列表元素是比较麻烦的操作。<br><code>collections.deque</code>是一个线程安全、可以快速从两端添加或者删除元素的数据类型。</p><ul><li>s.append(e) 添加一个元素到最右侧</li><li>s.appendleft(e) 添加一个元素到最左侧</li><li>s.extend(i) 将可迭代对象i中的元素<strong>依次</strong>添加到尾部</li><li>s.extendleft(i) 将可迭代对象i中的元素<strong>依次</strong>添加到头部</li></ul><h1 id="Chap-3-字典和集合"><a href="#Chap-3-字典和集合" class="headerlink" title="Chap 3 字典和集合"></a>Chap 3 字典和集合</h1><h2 id="3-1-泛映射类型"><a href="#3-1-泛映射类型" class="headerlink" title="3.1 泛映射类型"></a>3.1 泛映射类型</h2><p>标准库里的所有映射类型都是利用dict来实现的， 因此只有可散列的数据类型才能用作这些映射里的<strong>键</strong>，（值无要求）。</p><h3 id="可散列的数据类型"><a href="#可散列的数据类型" class="headerlink" title="可散列的数据类型"></a>可散列的数据类型</h3><p>如果一个对象是可散列的，那么在这个对象的生命周期中，它的散列值是不变的，而且这个对象需要实现<code>__hash__()</code>方法，和<code>__eq__()</code>方法来跟其他键作比较，如果这两个可散列对象是相等的，那么它们的散列值一定相等。<br>原子不可变数据类型（str, bytes 和数值类型）都是可散列类型。  </p><h2 id="3-2-字典推导"><a href="#3-2-字典推导" class="headerlink" title="3.2 字典推导"></a>3.2 字典推导</h2><p>Python2.7 后将列表推导和生成器表达式的概念移植到了字典上。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DIAL_CODES = [</span><br><span class="line">        (<span class="number">86</span>, <span class="string">'China'</span>),</span><br><span class="line">        (<span class="number">91</span>, <span class="string">'India'</span>),</span><br><span class="line">        (<span class="number">1</span>, <span class="string">'United States'</span>)</span><br><span class="line">    ]</span><br><span class="line">country_code = &#123; country: code <span class="keyword">for</span> code, country <span class="keyword">in</span> DIAL_CODES&#125;</span><br></pre></td></tr></table></figure></p><h2 id="3-3-常见的映射方法"><a href="#3-3-常见的映射方法" class="headerlink" title="3.3 常见的映射方法"></a>3.3 常见的映射方法</h2><p>page 57  </p><h3 id="用setdefault处理找不到的键"><a href="#用setdefault处理找不到的键" class="headerlink" title="用setdefault处理找不到的键"></a>用setdefault处理找不到的键</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_dict.setdefault(word, []).append(location)</span><br></pre></td></tr></table></figure><p>等同于<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> my_dict:</span><br><span class="line">    my_dict[key] = []</span><br><span class="line">my_dict[key].append(location)</span><br></pre></td></tr></table></figure></p><p>后者需要至少两次的键查询，如果键不存在，需要3次。<br>而<code>setdefault</code>只需要一次。</p><h2 id="3-4-映射的弹性键查询"><a href="#3-4-映射的弹性键查询" class="headerlink" title="3.4 映射的弹性键查询"></a>3.4 映射的弹性键查询</h2><p>setdefault是在插入值的时候检查键， 如果我们在单纯查找键的之后，也能在键不存在的时候得到一个默认值，有两种方法：</p><ol><li>通过defaultdict这个类型，而不是普通的dict类</li><li>定义一个dict的子类，在子类中实现<code>__missing__</code>方法  </li></ol><h3 id="defaultdict"><a href="#defaultdict" class="headerlink" title="defaultdict"></a>defaultdict</h3><p>用户在创建defaultdict对象的时候，需要给构造方法提供一个可调用对象，在<code>__getitem__</code>找不到键的时候调用它，返回某个默认值。  </p><ol><li>创建<code>dd = defaultdict(list)</code>，访问键<code>new-key</code>不存在</li><li>调用<code>list()</code>生成一个新的列表</li><li>将这个列表作为值，<code>new-key</code>作为键，放在<code>dd</code>中</li><li>返回这个列表的引用</li></ol><p>如果在创建defaultdict的时候没有指定<code>default_factory</code>，查询不存在的键会报错。<code>default_factory</code>只对<code>__getitem__</code>有效</p><h3 id="特殊方法missing"><a href="#特殊方法missing" class="headerlink" title="特殊方法missing"></a>特殊方法<strong>missing</strong></h3><p>所有映射类型在处理找不到的键时都会牵扯到<code>__missing__</code>方法。<br><code>__missing__</code>方法只对<code>__getitem__</code>有效，对<code>get</code>或<code>contains</code>无效。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrKeyDict0</span><span class="params">(dict)</span>:</span>  <span class="comment"># &lt;1&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__missing__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(key, str):  <span class="comment"># &lt;2&gt;</span></span><br><span class="line">            <span class="keyword">raise</span> KeyError(key)</span><br><span class="line">        <span class="keyword">return</span> self[str(key)]  <span class="comment"># &lt;3&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key, default=None)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> self[key]  <span class="comment"># &lt;4&gt;</span></span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            <span class="keyword">return</span> default  <span class="comment"># &lt;5&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__contains__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> key <span class="keyword">in</span> self.keys() <span class="keyword">or</span> str(key) <span class="keyword">in</span> self.keys()  <span class="comment"># &lt;6&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Tests for item retrieval using `d[key]` notation::</span><br><span class="line">&gt;&gt;&gt; d = StrKeyDict0([(&apos;2&apos;, &apos;two&apos;), (&apos;4&apos;, &apos;four&apos;)])</span><br><span class="line">&gt;&gt;&gt; d[&apos;2&apos;]</span><br><span class="line">&apos;two&apos;</span><br><span class="line">&gt;&gt;&gt; d[4]</span><br><span class="line">&apos;four&apos;</span><br><span class="line">&gt;&gt;&gt; d[1]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">    ...</span><br><span class="line">KeyError: &apos;1&apos;</span><br><span class="line">Tests for item retrieval using `d.get(key)` notation::</span><br><span class="line">&gt;&gt;&gt; d.get(&apos;2&apos;)</span><br><span class="line">&apos;two&apos;</span><br><span class="line">&gt;&gt;&gt; d.get(4)</span><br><span class="line">&apos;four&apos;</span><br><span class="line">&gt;&gt;&gt; d.get(1, &apos;N/A&apos;)</span><br><span class="line">&apos;N/A&apos;</span><br><span class="line">Tests for the `in` operator::</span><br><span class="line">&gt;&gt;&gt; 2 in d</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; 1 in d</span><br><span class="line">False</span><br></pre></td></tr></table></figure><h2 id="3-5-字典的变种"><a href="#3-5-字典的变种" class="headerlink" title="3.5 字典的变种"></a>3.5 字典的变种</h2><p>在collections模块中，除了defaultdict之外，还有：</p><ul><li>collections.OrderDict: 添加键的时候会保持顺序。  </li><li>collections.ChainMap: 可以容纳数个不同的映射对象，在进行键查找的时候，这些对象会被当作一个整体被逐个查找，直到这个键被找到为止。</li><li>collections.Counter: 给键提供整数计数器</li><li>collections.UserDict: 把标准dict用纯Python实现</li></ul><h2 id="3-6-子类化UserDict"><a href="#3-6-子类化UserDict" class="headerlink" title="3.6 子类化UserDict"></a>3.6 子类化UserDict</h2><p>倾向于用UserDict而不是从dict继承，主要是因为后者会在某些方法的实现上走捷径，使得我们需要在子类中重写。<br>UserDict不是dict的子类，在UserDict中的data属性是dict的实例，是UserDict最终存储数据的地方。</p><h2 id="3-7-不可变映射类型"><a href="#3-7-不可变映射类型" class="headerlink" title="3.7 不可变映射类型"></a>3.7 不可变映射类型</h2><p>标准库里的所有映射类型都是不可变的。<br>从Python3.3，types模块中引入了一个封装类名叫<code>MappingProxyType</code>, 如果给这个类一个映射，他会返回一个<strong>只读</strong>的映射视图。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> types <span class="keyword">import</span> MappingProxyType</span><br><span class="line">d = &#123;<span class="number">1</span> : <span class="string">'A'</span>&#125;</span><br><span class="line">d_proxy = MappingProxyType(d)</span><br></pre></td></tr></table></figure></p><p><code>d</code>中的内容可通过<code>d_proxy</code>查看，并且是随着<code>d</code>动态更新的。但是不能对<code>d_proxy</code>进行修改。  </p><h2 id="3-8-集合论"><a href="#3-8-集合论" class="headerlink" title="3.8 集合论"></a>3.8 集合论</h2><p>集合的本质是许多唯一对象的聚集。-&gt; 可以用于去重。<br>集合中的元素必须是可散列的，但set本身是不可散列的，而frozenset可以。</p><p><strong>中缀运算符</strong></p><ul><li>a | b 返回合集</li><li>a &amp; b 返回交集</li><li>a - b 返回差集</li></ul><h3 id="集合字面量"><a href="#集合字面量" class="headerlink" title="集合字面量"></a>集合字面量</h3><p>空集必须写成<code>set()</code>的形式，否则<code>{}</code>会被认为是字典。而非空集，可以以数学形式写出，即{1，2，3，4}.<br>遇到{1，2，3}这样的字面量，Python会利用BUILD_SET字节码来创建集合。<br>而构造方法<code>set([1,2,3])</code>会先用set来查询构造方法，然后新建一个列表，再把这个列表传入构造方法中。<br>而frozenset没有对应的特殊字面量句法，只能使用构造方法<code>frozenset([1,2,3])</code>  </p><h3 id="集合推导"><a href="#集合推导" class="headerlink" title="集合推导"></a>集合推导</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> unicodedata <span class="keyword">import</span> name</span><br><span class="line">&#123;chr(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>, <span class="number">256</span>) <span class="keyword">if</span> <span class="string">'SIGN'</span> <span class="keyword">in</span> name(chr(i), <span class="string">''</span>)&#125;</span><br></pre></td></tr></table></figure><h3 id="集合的操作"><a href="#集合的操作" class="headerlink" title="集合的操作"></a>集合的操作</h3><h2 id="3-9-dict和set的背后"><a href="#3-9-dict和set的背后" class="headerlink" title="3.9 dict和set的背后"></a>3.9 dict和set的背后</h2><h3 id="字典中的散列表"><a href="#字典中的散列表" class="headerlink" title="字典中的散列表"></a>字典中的散列表</h3><p>散列表是一个稀疏数组，散列表中的单元一般称为表元，表元大小一致。<br>在dict的散列表中，每个键值对占用一个表元，每个表元有两个部分，一个是对键的引用，一个是对值的引用。可以通过偏移量来读取某个表元。<br>Python会设法保证大概还有三分之一的表元为空，所以在即将到达这个阈值时，原散列表会被复制到更大的空间里。<br>要把对象放入散列表，首先计算这个元素键的散列值，Python中用hash()。</p><ol><li>散列值和相等性<br>内置的hash()可以用于所有内置类型对象。自定义对象调用hash()运行的是自定义的<code>__hash__</code>。<br>如果两个对象在比较时是相等的，它们的散列值也必须相等。<br>在Python3.3之后，str, bytes和datetime对象的散列值计算时多了随机<strong>加盐</strong>的过程，所加盐值是Python进程内的一个常量，每次启动Python解释器会生成不同的盐值。这是为了防止DOS攻击。</li><li>散列表算法  </li></ol><p><img src="/images/blogs/hash.png" alt></p><h3 id="dict的实现及其导致的结果"><a href="#dict的实现及其导致的结果" class="headerlink" title="dict的实现及其导致的结果"></a>dict的实现及其导致的结果</h3><ol><li>键必须是可散列的</li><li>字典在内存上的开销巨大</li><li>键查询很快</li><li>键的次序取决于添加顺序</li><li>往字典里新加键可能会改变已有顺序<br>加键时可能会导致字典被扩容。所以不要对字典同时进行迭代和修改操作</li></ol><h3 id="set的实现以及导致的结果"><a href="#set的实现以及导致的结果" class="headerlink" title="set的实现以及导致的结果"></a>set的实现以及导致的结果</h3><p>set和frozenset在散列表中存放的只有元素的引用。</p><ol><li>元素必须是可散列的</li><li>很消耗内存</li><li>可以高效判断元素是否存在于集合内</li><li>元素的次序取决于添加顺序</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Chap-2-序列构成的数组&quot;&gt;&lt;a href=&quot;#Chap-2-序列构成的数组&quot; class=&quot;headerlink&quot; title=&quot;Chap 2 序列构成的数组&quot;&gt;&lt;/a&gt;Chap 2 序列构成的数组&lt;/h1&gt;&lt;h2 id=&quot;2-1-内置序列类型&quot;&gt;&lt;a href=&quot;#2-1-内置序列类型&quot; class=&quot;headerlink&quot; title=&quot;2.1 内置序列类型&quot;&gt;&lt;/a&gt;2.1 内置序列类型&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;容器序列&lt;/strong&gt; 存放的是所包含的任意类型的对象的引用。list, tuple, collections.deque等&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;扁平序列&lt;/strong&gt; 存放的是值，是一段连续的内存空间，更为紧凑，但只能存放字符、字节和数值这种基础类型。str, bytes, bytearray, memoryview, array.array等  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;或者根据能否被修改来分类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;可变序列&lt;/strong&gt; list, bytearray, array.array, collections.deque和memoryview。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不可变序列&lt;/strong&gt; tuple, str, bytes
    
    </summary>
    
    
      <category term="Fluent Python" scheme="https://soundquiet.github.io/categories/Fluent-Python/"/>
    
    
      <category term="Python" scheme="https://soundquiet.github.io/tags/Python/"/>
    
      <category term="读书笔记" scheme="https://soundquiet.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>React学习笔记(1)</title>
    <link href="https://soundquiet.github.io/2018/08/18/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/"/>
    <id>https://soundquiet.github.io/2018/08/18/React学习笔记-1/</id>
    <published>2018-08-18T02:56:55.000Z</published>
    <updated>2018-08-18T03:51:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React入门"><a href="#React入门" class="headerlink" title="React入门"></a>React入门</h1><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><h3 id="JavaScript-for-Cats"><a href="#JavaScript-for-Cats" class="headerlink" title="JavaScript for Cats"></a>JavaScript for Cats</h3><p><a href="http://jsforcats.com/" target="_blank" rel="noopener">http://jsforcats.com/</a></p><h3 id="ES6-for-React-Native-Developers"><a href="#ES6-for-React-Native-Developers" class="headerlink" title="ES6 for React Native Developers"></a>ES6 for React Native Developers</h3><p><a href="https://medium.com/the-react-native-log/a-brief-overview-of-es6-for-react-native-developers-15e7c68315da" target="_blank" rel="noopener">https://medium.com/the-react-native-log/a-brief-overview-of-es6-for-react-native-developers-15e7c68315da</a></p><h4 id="let-vs-var-vs-const"><a href="#let-vs-var-vs-const" class="headerlink" title="let vs. var vs. const"></a><code>let</code> vs. <code>var</code> vs. <code>const</code></h4><p><code>let</code>和<code>var</code>相似，但是scope不同。<code>var</code>是function scoped, <code>let</code>是block scoped.</p><p><code>const</code>和<code>let</code>有相同scope，但是不能改变值。<br><a id="more"></a></p><h4 id="Array-Functions"><a href="#Array-Functions" class="headerlink" title="Array Functions"></a>Array Functions</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x =&gt; x*x</span><br></pre></td></tr></table></figure><p>等同于<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>箭头函数</code>相当于匿名函数。有两种格式。一种是只包含一个表达式，不带{…}和return。一种可以包含多条语句，比如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> x * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> - x * x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意，如果返回的是一个对象的话，要避免和函数体语法冲突，比如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x =&gt; (&#123;<span class="attr">foo</span>: x&#125;)</span><br></pre></td></tr></table></figure></p><p><strong>箭头函数和匿名函数的区别</strong>： 箭头函数内部的<code>this</code>是词法作用域，由上下文确定。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    getAge: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> b = <span class="keyword">this</span>.birth; <span class="comment">// 1990</span></span><br><span class="line">        <span class="keyword">var</span> fn = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear() - <span class="keyword">this</span>.birth; <span class="comment">// this指向obj对象</span></span><br><span class="line">        <span class="keyword">return</span> fn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.getAge(); <span class="comment">// 25</span></span><br></pre></td></tr></table></figure></p><p>否则要用<code>var that = this</code>来解决。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">arr.sort(<span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt;= y;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [1, 2, 10, 20]</span></span><br></pre></td></tr></table></figure><p><a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001438565969057627e5435793645b7acaee3b6869d1374000" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001438565969057627e5435793645b7acaee3b6869d1374000</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">JavaScript Array.sort()</span><br><span class="line"></span><br><span class="line">默认是按照字符顺序排列的，如果想自定义顺序，需要构造比较函数，该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数 a 和 b，其返回值如下：</span><br><span class="line"></span><br><span class="line">- 若 a 小于 b，在排序后的数组中 a 应该出现在 b 之前，则返回一个小于 0 的值。</span><br><span class="line">- 若 a 等于 b，则返回 0。</span><br><span class="line">- 若 a 大于 b，则返回一个大于 0 的值。</span><br></pre></td></tr></table></figure><h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><h3 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h3><p>一种JavaScript的语法扩展，推荐在React中使用JSX来描述用户界面。</p><p><strong>注</strong> 因为 JSX 的特性更接近 JavaScript 而不是 HTML , 所以 React DOM 使用 camelCase 小驼峰命名 来定义属性的名称，而不是使用 HTML 的属性名称。例如，<code>class</code> 变成了<code>className</code>，而<code>tabindex</code>则对应着 tabIndex。</p><p>React DOM在渲染之前默认过滤所有传入的值。所有的内容在渲染之前都被转换成了字符串。这样可以有效地防止 XSS(跨站脚本) 攻击。</p><h3 id="元素渲染"><a href="#元素渲染" class="headerlink" title="元素渲染"></a>元素渲染</h3><p>元素是构成React应用的最小单位。元素用来描述你在屏幕上看到的内容。</p><p>与浏览器的 DOM 元素不同，React 当中的元素事实上是普通的对象，React DOM 可以确保 浏览器 DOM 的数据内容与 React 元素保持一致。</p><p><strong>注</strong> 在React开发中一般只会定义一个根节点，但是如果是在已有项目中引入React的话，可能需要在不同部分单独定义React根节点。</p><p>要把React元素渲染到根DOM节点中，通过将他们传递给<code>ReactDOM.render()</code>方法中。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    element,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>);</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>React元素是<strong>不可变的</strong>，当元素被创建后，是无法改变其内容或者属性的。它代表应用界面在某一个时间点的样子。</p><p>可以通过创建一个新元素，将它传入<code>ReactDOM.render()</code>方法.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> element = (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">      &lt;h2&gt;It is &#123;<span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">  ReactDOM.render(</span><br><span class="line">    element,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setInterval(tick, <span class="number">1000</span>);</span><br><span class="line"><span class="comment">// 每秒钟调用一次tick方法</span></span><br></pre></td></tr></table></figure></p><p>在实际开发中，大多数React应用只会调用一次  <code>ReactDOM.render()</code>。</p><p>React DOM 首先会比较元素内容先后的不同，而在渲染过程中只会更新改变了的部分。</p><h3 id="组件和Props"><a href="#组件和Props" class="headerlink" title="组件和Props"></a>组件和Props</h3><p>组件可以将UI切分成一些可以复用的单独的部件。<br>组件可以接受任意输入值（称之为props），并返回一个需要在页面上展示的React元素。</p><p>定义一个组件最简单的方式是使用JavaScript函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Welcome</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>也可以用ES6 class来定义一个组件<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Welcome</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当React遇到的元素是用户自定义的组件，它会将JSX属性作为单个对象传递给该组件，这个对象称之为“props”。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Welcome</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">Welcome</span> <span class="attr">name</span>=<span class="string">"Sara"</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">ReactDOM.render(</span></span><br><span class="line"><span class="xml">  element,</span></span><br><span class="line"><span class="xml">  document.getElementById('root')</span></span><br><span class="line"><span class="xml">);</span></span><br></pre></td></tr></table></figure></p><p><strong>注</strong> 组件名称必须以大写字母开头。</p><p>例如，<code>&lt;div /&gt;</code> 表示一个DOM标签，但 <welcome> 表示一个组件，并且在使用该组件时你必须定义或引入它。</welcome></p><p>组件可以在它的输出中引用其它组件，这就可以让我们用同一组件来抽象出任意层次的细节。在React应用中，按钮、表单、对话框、整个屏幕的内容等，这些通常都被表示为组件。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Welcome</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Welcome name=<span class="string">"Sara"</span> /&gt;</span><br><span class="line">      &lt;Welcome name=<span class="string">"Cahal"</span> /&gt;</span><br><span class="line">      &lt;Welcome name=<span class="string">"Edite"</span> /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(</span></span><br><span class="line"><span class="regexp">  &lt;App /</span>&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>通常，一个新的React应用程序的顶部是一个App组件。但是，如果要将React集成到现有应用程序中，则可以从下而上使用像Button这样的小组件作为开始，并逐渐运用到视图层的顶部。</p><p>组件的返回值只能有一个根元素。这也是我们要用一个<code>&lt;div&gt;</code>来包裹所有<code>&lt;Welcome /&gt;</code>元素的原因。</p><p><strong>组件提取</strong><br>略</p><p>React有一个规则，<strong>所有的React组件必须像纯函数那样使用它们的props。</strong></p><p><strong>纯函数</strong>是指不改变自身输入的值的函数。当传入的值相同，总是会返回相同的结果。</p><h3 id="state和生命周期"><a href="#state和生命周期" class="headerlink" title="state和生命周期"></a>state和生命周期</h3><p>更新UI的正确方法</p><p>状态与属性十分相似，但是状态是私有的，完全受控于当前组件。</p><p>我们之前提到过，定义为类的组件有一些特性。局部状态就是如此：一个功能只适用于类。</p><p>可以通过5个步骤将函数组件 Clock 转换为类：</p><ol><li>创建一个名称扩展为 React.Component 的ES6 类</li><li>创建一个叫做render()的空方法</li><li>将函数体移动到 render() 方法中</li><li>在 render() 方法中，使用 this.props 替换 props</li><li>删除剩余的空函数声明<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">        &lt;h2&gt;It is &#123;<span class="keyword">this</span>.props.date.toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ReactDOM.render(</span><br><span class="line">    &lt;Clock date=&#123;<span class="keyword">new</span> <span class="built_in">Date</span>()&#125; /&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setInterval(tick, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure></li></ol><p>Clock 现在被定义为一个类而不只是一个函数。使用类就允许我们使用其它特性，例如局部状态、生命周期钩子。</p><h4 id="为一个类添加局部状态"><a href="#为一个类添加局部状态" class="headerlink" title="为一个类添加局部状态"></a>为一个类添加局部状态</h4><p>通过3个步骤将<code>date</code>从属性移动到状态中。</p><ol><li><p>在<code>render()</code>方法中使用<code>this.state.date</code>代替<code>this.props.date</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">        &lt;h2&gt;It is &#123;<span class="keyword">this</span>.state.date.toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>添加一个<strong>类构造函数</strong>来初始化状态<code>this.state</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;<span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>类组件应始终使用<code>props</code>调用基础构造函数。</p><ol start="3"><li>从<code>&lt;Clock /&gt;</code>元素中移除<code>date</code>属性。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Clock /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ol><h4 id="将生命周期方法添加到类中"><a href="#将生命周期方法添加到类中" class="headerlink" title="将生命周期方法添加到类中"></a>将生命周期方法添加到类中</h4><p>销毁组件时要释放组建所占用的资源。<br>每当Clock组件第一次加载到DOM中的时候，我们都想生成定时器，这在React中被称为<strong>挂载</strong></p><p>同样，每当Clock生成的这个DOM被移除的时候，我们也会想要清除定时器，这在React中被称为<strong>卸载</strong>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生命周期钩子</span></span><br><span class="line">componentDidMount() &#123;</span><br><span class="line">    <span class="comment">// 当组件输出到DOM后会执行</span></span><br><span class="line">    <span class="keyword">this</span>.timerID = setInterval(</span><br><span class="line">    () =&gt; <span class="keyword">this</span>.tick(),</span><br><span class="line">    <span class="number">1000</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">componentWillUnmount() &#123;</span><br><span class="line">    <span class="comment">// 卸载</span></span><br><span class="line">    clearInterval(<span class="keyword">this</span>.timeID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意如何在<code>this</code>中保存定时器ID。</p><p>虽然 this.props 由React本身设置以及this.state 具有特殊的含义，但如果需要存储不用于视觉输出的东西，则可以手动向类中添加其他字段。如果你不在 render() 中使用某些东西，它就不应该在状态中。</p><p><code>tick()</code>方法使用<code>this.setState()</code>来更新组件局部状态。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;<span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.timerID = setInterval(</span><br><span class="line">      () =&gt; <span class="keyword">this</span>.tick(),</span><br><span class="line">      <span class="number">1000</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    clearInterval(<span class="keyword">this</span>.timerID);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  tick() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      date: <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">        &lt;h2&gt;It is &#123;<span class="keyword">this</span>.state.date.toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Clock /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>整个过程如下：</p><ol><li><p>当 <clock> 被传递给 ReactDOM.render() 时，React 调用 Clock 组件的构造函数。 由于 Clock 需要显示当前时间，所以使用包含当前时间的对象来初始化 this.state 。 我们稍后会更新此状态。</clock></p></li><li><p>React 然后调用 Clock 组件的 render() 方法。这是 React 了解屏幕上应该显示什么内容，然后 React 更新 DOM 以匹配 Clock 的渲染输出。</p></li><li><p>当 Clock 的输出插入到 DOM 中时，React 调用 componentDidMount() 生命周期钩子。 在其中，Clock 组件要求浏览器设置一个定时器，每秒钟调用一次 tick()。</p></li><li><p>浏览器每秒钟调用 tick() 方法。 在其中，Clock 组件通过使用包含当前时间的对象调用 setState() 来调度UI更新。 通过调用 setState() ，React 知道状态已经改变，并再次调用 render() 方法来确定屏幕上应当显示什么。 这一次，render() 方法中的 this.state.date 将不同，所以渲染输出将包含更新的时间，并相应地更新DOM。</p></li><li><p>一旦Clock组件被从DOM中移除，React会调用componentWillUnmount()这个钩子函数，定时器也就会被清除。</p></li></ol><h4 id="正确使用状态"><a href="#正确使用状态" class="headerlink" title="正确使用状态"></a>正确使用状态</h4><ol><li><strong>不要直接更新状态</strong></li></ol><p>不要直接<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.state.comment = <span class="string">"Hello"</span>;</span><br></pre></td></tr></table></figure></p><p>而是使用<code>setState()</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(&#123;<span class="attr">comment</span>: <span class="string">"Hello"</span>&#125;);</span><br></pre></td></tr></table></figure></p><p><strong>构造函数是唯一能够初始化<code>this.state</code>的地方</strong></p><ol start="2"><li><strong>状态更新可能是异步的</strong></li></ol><p>React 可以将多个<code>setState()</code>调用合并成一个调用来提高性能。</p><p>因为<code>this.props</code>和<code>this.state</code>可能是异步更新的，你不应该依靠它们的值来计算下一个状态。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState, props</span>) =&gt;</span> (&#123;</span><br><span class="line">  counter: prevState.counter + props.increment</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure></p><p>该函数将接收先前的状态作为第一个参数，将此次更新被应用时的props做为第二个参数.</p><ol start="3"><li><strong>状态更新合并</strong></li></ol><p>当你调用<code>setState()</code>时，React将你提供的对象合并到当前状态。</p><p>例如，你的状态可能包含一些独立的变量：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">  <span class="keyword">super</span>(props);</span><br><span class="line">  <span class="keyword">this</span>.state = &#123;</span><br><span class="line">    posts: [],</span><br><span class="line">    comments: []</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>你可以调用<code>setState()</code>独立地更新它们：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">  fetchPosts().then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      posts: response.posts</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  fetchComments().then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      comments: response.comments</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里的合并是浅合并，也就是说<code>this.setState({comments})</code>完整保留了<code>this.state.posts</code>，但完全替换了<code>this.state.comments</code>。</p><h4 id="数据自顶向下流动"><a href="#数据自顶向下流动" class="headerlink" title="数据自顶向下流动"></a>数据自顶向下流动</h4><p><code>自顶向下</code>或<code>单向数据流</code>: 任何状态始终由某些特定组件所有，并且从该状态导出的任何数据或 UI 只能影响树中下方的组件。</p><p>如果你想象一个组件树作为属性的瀑布，每个组件的状态就像一个额外的水源，它连接在一个任意点，但也流下来。</p><p>父组件或子组件都不能知道某个组件是有状态还是无状态，并且它们不应该关心某组件是被定义为一个函数还是一个类。</p><h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;React入门&quot;&gt;&lt;a href=&quot;#React入门&quot; class=&quot;headerlink&quot; title=&quot;React入门&quot;&gt;&lt;/a&gt;React入门&lt;/h1&gt;&lt;h2 id=&quot;JavaScript&quot;&gt;&lt;a href=&quot;#JavaScript&quot; class=&quot;headerlink&quot; title=&quot;JavaScript&quot;&gt;&lt;/a&gt;JavaScript&lt;/h2&gt;&lt;h3 id=&quot;JavaScript-for-Cats&quot;&gt;&lt;a href=&quot;#JavaScript-for-Cats&quot; class=&quot;headerlink&quot; title=&quot;JavaScript for Cats&quot;&gt;&lt;/a&gt;JavaScript for Cats&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://jsforcats.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://jsforcats.com/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;ES6-for-React-Native-Developers&quot;&gt;&lt;a href=&quot;#ES6-for-React-Native-Developers&quot; class=&quot;headerlink&quot; title=&quot;ES6 for React Native Developers&quot;&gt;&lt;/a&gt;ES6 for React Native Developers&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://medium.com/the-react-native-log/a-brief-overview-of-es6-for-react-native-developers-15e7c68315da&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://medium.com/the-react-native-log/a-brief-overview-of-es6-for-react-native-developers-15e7c68315da&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;let-vs-var-vs-const&quot;&gt;&lt;a href=&quot;#let-vs-var-vs-const&quot; class=&quot;headerlink&quot; title=&quot;let vs. var vs. const&quot;&gt;&lt;/a&gt;&lt;code&gt;let&lt;/code&gt; vs. &lt;code&gt;var&lt;/code&gt; vs. &lt;code&gt;const&lt;/code&gt;&lt;/h4&gt;&lt;p&gt;&lt;code&gt;let&lt;/code&gt;和&lt;code&gt;var&lt;/code&gt;相似，但是scope不同。&lt;code&gt;var&lt;/code&gt;是function scoped, &lt;code&gt;let&lt;/code&gt;是block scoped.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;const&lt;/code&gt;和&lt;code&gt;let&lt;/code&gt;有相同scope，但是不能改变值。&lt;br&gt;
    
    </summary>
    
    
    
      <category term="React" scheme="https://soundquiet.github.io/tags/React/"/>
    
  </entry>
  
</feed>
